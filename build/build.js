(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/apollo-fetch/dist/apollo-fetch.js":
/*!********************************************************!*\
  !*** ./node_modules/apollo-fetch/dist/apollo-fetch.js ***!
  \********************************************************/
/*! exports provided: constructDefaultOptions, createApolloFetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constructDefaultOptions\", function() { return constructDefaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createApolloFetch\", function() { return createApolloFetch; });\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch/polyfill */ \"./node_modules/cross-fetch/dist/browser-polyfill.js\");\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\nfunction buildWareStack(funcs, modifiedObject, resolve) {\n    var _this = this;\n    var next = function () {\n        if (funcs.length > 0) {\n            var f = funcs.shift();\n            if (f) {\n                f.apply(_this, [modifiedObject, next]);\n            }\n        }\n        else {\n            resolve(modifiedObject);\n        }\n    };\n    next();\n}\nfunction constructDefaultOptions(requestOrRequests, options) {\n    var body;\n    try {\n        body = JSON.stringify(requestOrRequests);\n    }\n    catch (e) {\n        throw new Error(\"Network request failed. Payload is not serializable: \" + e.message);\n    }\n    return __assign({ body: body, method: 'POST' }, options, { headers: __assign({ Accept: '*/*', 'Content-Type': 'application/json' }, options.headers || []) });\n}\nfunction throwHttpError(response, error) {\n    var httpError;\n    if (response && response.status >= 300) {\n        httpError = new Error(\"Network request failed with status \" + response.status + \" - \\\"\" + response.statusText + \"\\\"\");\n    }\n    else {\n        httpError = new Error(\"Network request failed to return valid JSON\");\n    }\n    httpError.response = response;\n    httpError.parseError = error;\n    throw httpError;\n}\nfunction throwBatchError(response) {\n    var httpError = new Error(\"A batched Operation of responses for \");\n    httpError.response = response;\n    throw httpError;\n}\nfunction createApolloFetch(params) {\n    if (params === void 0) { params = {}; }\n    var constructOptions = params.constructOptions, customFetch = params.customFetch;\n    var _uri = params.uri || '/graphql';\n    var middlewares = [];\n    var batchedMiddlewares = [];\n    var afterwares = [];\n    var batchedAfterwares = [];\n    var applyMiddlewares = function (requestAndOptions, batched) {\n        return new Promise(function (resolve, reject) {\n            if (batched) {\n                buildWareStack(batchedMiddlewares.slice(), requestAndOptions, resolve);\n            }\n            else {\n                buildWareStack(middlewares.slice(), requestAndOptions, resolve);\n            }\n        });\n    };\n    var applyAfterwares = function (responseObject, batched) {\n        return new Promise(function (resolve, reject) {\n            if (batched) {\n                buildWareStack(batchedAfterwares.slice(), responseObject, resolve);\n            }\n            else {\n                buildWareStack(afterwares.slice(), responseObject, resolve);\n            }\n        });\n    };\n    var apolloFetch = function (request) {\n        var options = {};\n        var parseError;\n        var batched = Array.isArray(request);\n        var requestObject = (batched\n            ? {\n                requests: request,\n                options: options,\n            }\n            : {\n                request: request,\n                options: options,\n            });\n        return applyMiddlewares(requestObject, batched)\n            .then(function (reqOpts) {\n            var construct = constructOptions || constructDefaultOptions;\n            var requestOrRequests = reqOpts.request ||\n                reqOpts.requests;\n            return construct(requestOrRequests, reqOpts.options);\n        })\n            .then(function (opts) {\n            options = __assign({}, opts);\n            return (customFetch || fetch)(_uri, options);\n        })\n            .then(function (response) {\n            return response.text().then(function (raw) {\n                try {\n                    var parsed = JSON.parse(raw);\n                    response.raw = raw;\n                    response.parsed = parsed;\n                    return response;\n                }\n                catch (e) {\n                    parseError = e;\n                    response.raw = raw;\n                    return response;\n                }\n            });\n        })\n            .then(function (response) {\n            return applyAfterwares({\n                response: response,\n                options: options,\n            }, batched);\n        })\n            .then(function (_a) {\n            var response = _a.response;\n            if (response.parsed) {\n                if (batched) {\n                    if (Array.isArray(response.parsed)) {\n                        return response.parsed;\n                    }\n                    else {\n                        throwBatchError(response);\n                    }\n                }\n                else {\n                    return __assign({}, response.parsed);\n                }\n            }\n            else {\n                throwHttpError(response, parseError);\n            }\n        });\n    };\n    apolloFetch.use = function (middleware) {\n        if (typeof middleware === 'function') {\n            middlewares.push(middleware);\n        }\n        else {\n            throw new Error('Middleware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.useAfter = function (afterware) {\n        if (typeof afterware === 'function') {\n            afterwares.push(afterware);\n        }\n        else {\n            throw new Error('Afterware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.batchUse = function (middleware) {\n        if (typeof middleware === 'function') {\n            batchedMiddlewares.push(middleware);\n        }\n        else {\n            throw new Error('Middleware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.batchUseAfter = function (afterware) {\n        if (typeof afterware === 'function') {\n            batchedAfterwares.push(afterware);\n        }\n        else {\n            throw new Error('Afterware must be a function');\n        }\n        return apolloFetch;\n    };\n    return apolloFetch;\n}\n//# sourceMappingURL=apollo-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBvbGxvLWZldGNoL2Rpc3QvYXBvbGxvLWZldGNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1mZXRjaC9kaXN0L2Fwb2xsby1mZXRjaC5qcz8xYzU3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0ICdjcm9zcy1mZXRjaC9wb2x5ZmlsbCc7XG5mdW5jdGlvbiBidWlsZFdhcmVTdGFjayhmdW5jcywgbW9kaWZpZWRPYmplY3QsIHJlc29sdmUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGYgPSBmdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICBmLmFwcGx5KF90aGlzLCBbbW9kaWZpZWRPYmplY3QsIG5leHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobW9kaWZpZWRPYmplY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBuZXh0KCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0RGVmYXVsdE9wdGlvbnMocmVxdWVzdE9yUmVxdWVzdHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYm9keTtcbiAgICB0cnkge1xuICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxdWVzdE9yUmVxdWVzdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkLiBQYXlsb2FkIGlzIG5vdCBzZXJpYWxpemFibGU6IFwiICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKHsgYm9keTogYm9keSwgbWV0aG9kOiAnUE9TVCcgfSwgb3B0aW9ucywgeyBoZWFkZXJzOiBfX2Fzc2lnbih7IEFjY2VwdDogJyovKicsICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucy5oZWFkZXJzIHx8IFtdKSB9KTtcbn1cbmZ1bmN0aW9uIHRocm93SHR0cEVycm9yKHJlc3BvbnNlLCBlcnJvcikge1xuICAgIHZhciBodHRwRXJyb3I7XG4gICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgaHR0cEVycm9yID0gbmV3IEVycm9yKFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiIC0gXFxcIlwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCArIFwiXFxcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGh0dHBFcnJvciA9IG5ldyBFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQgdG8gcmV0dXJuIHZhbGlkIEpTT05cIik7XG4gICAgfVxuICAgIGh0dHBFcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIGh0dHBFcnJvci5wYXJzZUVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgaHR0cEVycm9yO1xufVxuZnVuY3Rpb24gdGhyb3dCYXRjaEVycm9yKHJlc3BvbnNlKSB7XG4gICAgdmFyIGh0dHBFcnJvciA9IG5ldyBFcnJvcihcIkEgYmF0Y2hlZCBPcGVyYXRpb24gb2YgcmVzcG9uc2VzIGZvciBcIik7XG4gICAgaHR0cEVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhyb3cgaHR0cEVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFwb2xsb0ZldGNoKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHZhciBjb25zdHJ1Y3RPcHRpb25zID0gcGFyYW1zLmNvbnN0cnVjdE9wdGlvbnMsIGN1c3RvbUZldGNoID0gcGFyYW1zLmN1c3RvbUZldGNoO1xuICAgIHZhciBfdXJpID0gcGFyYW1zLnVyaSB8fCAnL2dyYXBocWwnO1xuICAgIHZhciBtaWRkbGV3YXJlcyA9IFtdO1xuICAgIHZhciBiYXRjaGVkTWlkZGxld2FyZXMgPSBbXTtcbiAgICB2YXIgYWZ0ZXJ3YXJlcyA9IFtdO1xuICAgIHZhciBiYXRjaGVkQWZ0ZXJ3YXJlcyA9IFtdO1xuICAgIHZhciBhcHBseU1pZGRsZXdhcmVzID0gZnVuY3Rpb24gKHJlcXVlc3RBbmRPcHRpb25zLCBiYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkV2FyZVN0YWNrKGJhdGNoZWRNaWRkbGV3YXJlcy5zbGljZSgpLCByZXF1ZXN0QW5kT3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZFdhcmVTdGFjayhtaWRkbGV3YXJlcy5zbGljZSgpLCByZXF1ZXN0QW5kT3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGFwcGx5QWZ0ZXJ3YXJlcyA9IGZ1bmN0aW9uIChyZXNwb25zZU9iamVjdCwgYmF0Y2hlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKGJhdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBidWlsZFdhcmVTdGFjayhiYXRjaGVkQWZ0ZXJ3YXJlcy5zbGljZSgpLCByZXNwb25zZU9iamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZFdhcmVTdGFjayhhZnRlcndhcmVzLnNsaWNlKCksIHJlc3BvbnNlT2JqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgYXBvbGxvRmV0Y2ggPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgcGFyc2VFcnJvcjtcbiAgICAgICAgdmFyIGJhdGNoZWQgPSBBcnJheS5pc0FycmF5KHJlcXVlc3QpO1xuICAgICAgICB2YXIgcmVxdWVzdE9iamVjdCA9IChiYXRjaGVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0czogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcHBseU1pZGRsZXdhcmVzKHJlcXVlc3RPYmplY3QsIGJhdGNoZWQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVxT3B0cykge1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdCA9IGNvbnN0cnVjdE9wdGlvbnMgfHwgY29uc3RydWN0RGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdE9yUmVxdWVzdHMgPSByZXFPcHRzLnJlcXVlc3QgfHxcbiAgICAgICAgICAgICAgICByZXFPcHRzLnJlcXVlc3RzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdChyZXF1ZXN0T3JSZXF1ZXN0cywgcmVxT3B0cy5vcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIChjdXN0b21GZXRjaCB8fCBmZXRjaCkoX3VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbihmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmF3ID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJhdyA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlBZnRlcndhcmVzKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIH0sIGJhdGNoZWQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBfYS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5wYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5wYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dCYXRjaEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCByZXNwb25zZS5wYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93SHR0cEVycm9yKHJlc3BvbnNlLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhcG9sbG9GZXRjaC51c2UgPSBmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzLnB1c2gobWlkZGxld2FyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pZGRsZXdhcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwb2xsb0ZldGNoO1xuICAgIH07XG4gICAgYXBvbGxvRmV0Y2gudXNlQWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJ3YXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWZ0ZXJ3YXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhZnRlcndhcmVzLnB1c2goYWZ0ZXJ3YXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWZ0ZXJ3YXJlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcG9sbG9GZXRjaDtcbiAgICB9O1xuICAgIGFwb2xsb0ZldGNoLmJhdGNoVXNlID0gZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBiYXRjaGVkTWlkZGxld2FyZXMucHVzaChtaWRkbGV3YXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlkZGxld2FyZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBvbGxvRmV0Y2g7XG4gICAgfTtcbiAgICBhcG9sbG9GZXRjaC5iYXRjaFVzZUFmdGVyID0gZnVuY3Rpb24gKGFmdGVyd2FyZSkge1xuICAgICAgICBpZiAodHlwZW9mIGFmdGVyd2FyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmF0Y2hlZEFmdGVyd2FyZXMucHVzaChhZnRlcndhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZnRlcndhcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwb2xsb0ZldGNoO1xuICAgIH07XG4gICAgcmV0dXJuIGFwb2xsb0ZldGNoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBvbGxvLWZldGNoLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apollo-fetch/dist/apollo-fetch.js\n");

/***/ }),

/***/ "./node_modules/apollo-fetch/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/apollo-fetch/dist/index.js ***!
  \*************************************************/
/*! exports provided: constructDefaultOptions, createApolloFetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apollo-fetch */ \"./node_modules/apollo-fetch/dist/apollo-fetch.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constructDefaultOptions\", function() { return _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__[\"constructDefaultOptions\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createApolloFetch\", function() { return _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__[\"createApolloFetch\"]; });\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBvbGxvLWZldGNoL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBvbGxvLWZldGNoL2Rpc3QvaW5kZXguanM/YTg4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Fwb2xsby1mZXRjaCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apollo-fetch/dist/index.js\n");

/***/ }),

/***/ "./node_modules/clusters/clusters.js":
/*!*******************************************!*\
  !*** ./node_modules/clusters/clusters.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n\n  data: getterSetter([], function(arrayOfArrays) {\n    var n = arrayOfArrays[0].length;\n    return (arrayOfArrays.map(function(array) {\n      return array.length == n;\n    }).reduce(function(boolA, boolB) { return (boolA & boolB) }, true));\n  }),\n\n  clusters: function() {\n    var pointsAndCentroids = kmeans(this.data(), {k: this.k(), iterations: this.iterations() });\n    var points = pointsAndCentroids.points;\n    var centroids = pointsAndCentroids.centroids;\n\n    return centroids.map(function(centroid) {\n      return {\n        centroid: centroid.location(),\n        points: points.filter(function(point) { return point.label() == centroid.label() }).map(function(point) { return point.location() }),\n      };\n    });\n  },\n\n  k: getterSetter(undefined, function(value) { return ((value % 1 == 0) & (value > 0)) }),\n\n  iterations: getterSetter(Math.pow(10, 3), function(value) { return ((value % 1 == 0) & (value > 0)) }),\n\n};\n\nfunction kmeans(data, config) {\n  // default k\n  var k = config.k || Math.round(Math.sqrt(data.length / 2));\n  var iterations = config.iterations;\n\n  // initialize point objects with data\n  var points = data.map(function(vector) { return new Point(vector) });\n\n  // intialize centroids randomly\n  var centroids = [];\n  for (var i = 0; i < k; i++) {\n    centroids.push(new Centroid(points[i % points.length].location(), i));\n  };\n\n  // update labels and centroid locations until convergence\n  for (var iter = 0; iter < iterations; iter++) {\n    points.forEach(function(point) { point.updateLabel(centroids) });\n    centroids.forEach(function(centroid) { centroid.updateLocation(points) });\n  };\n\n  // return points and centroids\n  return {\n    points: points,\n    centroids: centroids\n  };\n\n};\n\n// objects\nfunction Point(location) {\n  var self = this;\n  this.location = getterSetter(location);\n  this.label = getterSetter();\n  this.updateLabel = function(centroids) {\n    var distancesSquared = centroids.map(function(centroid) {\n      return sumOfSquareDiffs(self.location(), centroid.location());\n    });\n    self.label(mindex(distancesSquared));\n  };\n};\n\nfunction Centroid(initialLocation, label) {\n  var self = this;\n  this.location = getterSetter(initialLocation);\n  this.label = getterSetter(label);\n  this.updateLocation = function(points) {\n    var pointsWithThisCentroid = points.filter(function(point) { return point.label() == self.label() });\n    if (pointsWithThisCentroid.length > 0) self.location(averageLocation(pointsWithThisCentroid));\n  };\n};\n\n// convenience functions\nfunction getterSetter(initialValue, validator) {\n  var thingToGetSet = initialValue;\n  var isValid = validator || function(val) { return true };\n  return function(newValue) {\n    if (typeof newValue === 'undefined') return thingToGetSet;\n    if (isValid(newValue)) thingToGetSet = newValue;\n  };\n};\n\nfunction sumOfSquareDiffs(oneVector, anotherVector) {\n  var squareDiffs = oneVector.map(function(component, i) {\n    return Math.pow(component - anotherVector[i], 2);\n  });\n  return squareDiffs.reduce(function(a, b) { return a + b }, 0);\n};\n\nfunction mindex(array) {\n  var min = array.reduce(function(a, b) {\n    return Math.min(a, b);\n  });\n  return array.indexOf(min);\n};\n\nfunction sumVectors(a, b) {\n  return a.map(function(val, i) { return val + b[i] });\n};\n\nfunction averageLocation(points) {\n  var zeroVector = points[0].location().map(function() { return 0 });\n  var locations = points.map(function(point) { return point.location() });\n  var vectorSum = locations.reduce(function(a, b) { return sumVectors(a, b) }, zeroVector);\n  return vectorSum.map(function(val) { return val / points.length });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2x1c3RlcnMvY2x1c3RlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2x1c3RlcnMvY2x1c3RlcnMuanM/ZDUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZGF0YTogZ2V0dGVyU2V0dGVyKFtdLCBmdW5jdGlvbihhcnJheU9mQXJyYXlzKSB7XG4gICAgdmFyIG4gPSBhcnJheU9mQXJyYXlzWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gKGFycmF5T2ZBcnJheXMubWFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkubGVuZ3RoID09IG47XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uKGJvb2xBLCBib29sQikgeyByZXR1cm4gKGJvb2xBICYgYm9vbEIpIH0sIHRydWUpKTtcbiAgfSksXG5cbiAgY2x1c3RlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb2ludHNBbmRDZW50cm9pZHMgPSBrbWVhbnModGhpcy5kYXRhKCksIHtrOiB0aGlzLmsoKSwgaXRlcmF0aW9uczogdGhpcy5pdGVyYXRpb25zKCkgfSk7XG4gICAgdmFyIHBvaW50cyA9IHBvaW50c0FuZENlbnRyb2lkcy5wb2ludHM7XG4gICAgdmFyIGNlbnRyb2lkcyA9IHBvaW50c0FuZENlbnRyb2lkcy5jZW50cm9pZHM7XG5cbiAgICByZXR1cm4gY2VudHJvaWRzLm1hcChmdW5jdGlvbihjZW50cm9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2VudHJvaWQ6IGNlbnRyb2lkLmxvY2F0aW9uKCksXG4gICAgICAgIHBvaW50czogcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwb2ludCkgeyByZXR1cm4gcG9pbnQubGFiZWwoKSA9PSBjZW50cm9pZC5sYWJlbCgpIH0pLm1hcChmdW5jdGlvbihwb2ludCkgeyByZXR1cm4gcG9pbnQubG9jYXRpb24oKSB9KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgazogZ2V0dGVyU2V0dGVyKHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICgodmFsdWUgJSAxID09IDApICYgKHZhbHVlID4gMCkpIH0pLFxuXG4gIGl0ZXJhdGlvbnM6IGdldHRlclNldHRlcihNYXRoLnBvdygxMCwgMyksIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlICUgMSA9PSAwKSAmICh2YWx1ZSA+IDApKSB9KSxcblxufTtcblxuZnVuY3Rpb24ga21lYW5zKGRhdGEsIGNvbmZpZykge1xuICAvLyBkZWZhdWx0IGtcbiAgdmFyIGsgPSBjb25maWcuayB8fCBNYXRoLnJvdW5kKE1hdGguc3FydChkYXRhLmxlbmd0aCAvIDIpKTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSBjb25maWcuaXRlcmF0aW9ucztcblxuICAvLyBpbml0aWFsaXplIHBvaW50IG9iamVjdHMgd2l0aCBkYXRhXG4gIHZhciBwb2ludHMgPSBkYXRhLm1hcChmdW5jdGlvbih2ZWN0b3IpIHsgcmV0dXJuIG5ldyBQb2ludCh2ZWN0b3IpIH0pO1xuXG4gIC8vIGludGlhbGl6ZSBjZW50cm9pZHMgcmFuZG9tbHlcbiAgdmFyIGNlbnRyb2lkcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgIGNlbnRyb2lkcy5wdXNoKG5ldyBDZW50cm9pZChwb2ludHNbaSAlIHBvaW50cy5sZW5ndGhdLmxvY2F0aW9uKCksIGkpKTtcbiAgfTtcblxuICAvLyB1cGRhdGUgbGFiZWxzIGFuZCBjZW50cm9pZCBsb2NhdGlvbnMgdW50aWwgY29udmVyZ2VuY2VcbiAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkgeyBwb2ludC51cGRhdGVMYWJlbChjZW50cm9pZHMpIH0pO1xuICAgIGNlbnRyb2lkcy5mb3JFYWNoKGZ1bmN0aW9uKGNlbnRyb2lkKSB7IGNlbnRyb2lkLnVwZGF0ZUxvY2F0aW9uKHBvaW50cykgfSk7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHBvaW50cyBhbmQgY2VudHJvaWRzXG4gIHJldHVybiB7XG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgY2VudHJvaWRzOiBjZW50cm9pZHNcbiAgfTtcblxufTtcblxuLy8gb2JqZWN0c1xuZnVuY3Rpb24gUG9pbnQobG9jYXRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmxvY2F0aW9uID0gZ2V0dGVyU2V0dGVyKGxvY2F0aW9uKTtcbiAgdGhpcy5sYWJlbCA9IGdldHRlclNldHRlcigpO1xuICB0aGlzLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24oY2VudHJvaWRzKSB7XG4gICAgdmFyIGRpc3RhbmNlc1NxdWFyZWQgPSBjZW50cm9pZHMubWFwKGZ1bmN0aW9uKGNlbnRyb2lkKSB7XG4gICAgICByZXR1cm4gc3VtT2ZTcXVhcmVEaWZmcyhzZWxmLmxvY2F0aW9uKCksIGNlbnRyb2lkLmxvY2F0aW9uKCkpO1xuICAgIH0pO1xuICAgIHNlbGYubGFiZWwobWluZGV4KGRpc3RhbmNlc1NxdWFyZWQpKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIENlbnRyb2lkKGluaXRpYWxMb2NhdGlvbiwgbGFiZWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmxvY2F0aW9uID0gZ2V0dGVyU2V0dGVyKGluaXRpYWxMb2NhdGlvbik7XG4gIHRoaXMubGFiZWwgPSBnZXR0ZXJTZXR0ZXIobGFiZWwpO1xuICB0aGlzLnVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgdmFyIHBvaW50c1dpdGhUaGlzQ2VudHJvaWQgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHBvaW50KSB7IHJldHVybiBwb2ludC5sYWJlbCgpID09IHNlbGYubGFiZWwoKSB9KTtcbiAgICBpZiAocG9pbnRzV2l0aFRoaXNDZW50cm9pZC5sZW5ndGggPiAwKSBzZWxmLmxvY2F0aW9uKGF2ZXJhZ2VMb2NhdGlvbihwb2ludHNXaXRoVGhpc0NlbnRyb2lkKSk7XG4gIH07XG59O1xuXG4vLyBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldHRlclNldHRlcihpbml0aWFsVmFsdWUsIHZhbGlkYXRvcikge1xuICB2YXIgdGhpbmdUb0dldFNldCA9IGluaXRpYWxWYWx1ZTtcbiAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0b3IgfHwgZnVuY3Rpb24odmFsKSB7IHJldHVybiB0cnVlIH07XG4gIHJldHVybiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpbmdUb0dldFNldDtcbiAgICBpZiAoaXNWYWxpZChuZXdWYWx1ZSkpIHRoaW5nVG9HZXRTZXQgPSBuZXdWYWx1ZTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHN1bU9mU3F1YXJlRGlmZnMob25lVmVjdG9yLCBhbm90aGVyVmVjdG9yKSB7XG4gIHZhciBzcXVhcmVEaWZmcyA9IG9uZVZlY3Rvci5tYXAoZnVuY3Rpb24oY29tcG9uZW50LCBpKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGNvbXBvbmVudCAtIGFub3RoZXJWZWN0b3JbaV0sIDIpO1xuICB9KTtcbiAgcmV0dXJuIHNxdWFyZURpZmZzLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYiB9LCAwKTtcbn07XG5cbmZ1bmN0aW9uIG1pbmRleChhcnJheSkge1xuICB2YXIgbWluID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oYSwgYik7XG4gIH0pO1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihtaW4pO1xufTtcblxuZnVuY3Rpb24gc3VtVmVjdG9ycyhhLCBiKSB7XG4gIHJldHVybiBhLm1hcChmdW5jdGlvbih2YWwsIGkpIHsgcmV0dXJuIHZhbCArIGJbaV0gfSk7XG59O1xuXG5mdW5jdGlvbiBhdmVyYWdlTG9jYXRpb24ocG9pbnRzKSB7XG4gIHZhciB6ZXJvVmVjdG9yID0gcG9pbnRzWzBdLmxvY2F0aW9uKCkubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9KTtcbiAgdmFyIGxvY2F0aW9ucyA9IHBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHsgcmV0dXJuIHBvaW50LmxvY2F0aW9uKCkgfSk7XG4gIHZhciB2ZWN0b3JTdW0gPSBsb2NhdGlvbnMucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bVZlY3RvcnMoYSwgYikgfSwgemVyb1ZlY3Rvcik7XG4gIHJldHVybiB2ZWN0b3JTdW0ubWFwKGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsIC8gcG9pbnRzLmxlbmd0aCB9KTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/clusters/clusters.js\n");

/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-polyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-polyfill.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue+','+value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push(name); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) { items.push(value); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push([name, value]); });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : this);\n\n/*\n * Rollup wraps up the whatwg-fetch code on ponyfill mode in\n * order to prevent it from adding fetch to the global object.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcz83Mjc0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCc7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfTtcbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cbi8qXG4gKiBSb2xsdXAgd3JhcHMgdXAgdGhlIHdoYXR3Zy1mZXRjaCBjb2RlIG9uIHBvbnlmaWxsIG1vZGUgaW5cbiAqIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbSBhZGRpbmcgZmV0Y2ggdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gKi9cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/cross-fetch/dist/browser-polyfill.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./src/app.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader??ref--4-1!./src/app.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n  .error-line {\\n    stroke:black;\\n    stroke-dasharray: 2,2;\\n  }\\n  \\n  .error-cap {\\n    stroke:black;\\n    stroke-width: 1px;\\n  }\\n  \\n    div.benchmark_tooltip {\\n      background-color: #fff;\\n      padding: 7px;\\n      text-shadow: #f5f5f5 0 1px 0;\\n      font: 15px Helvetica Neue;\\n      border: 4.5px solid;\\n      border-color: #0A58A2;\\n      border-radius: 3px;\\n      opacity: 0.95;\\n      position: absolute;\\n      box-shadow: rgba(0, 0, 0, 0.3) 0 10px 15px;\\n      z-index: 3;\\n    }\\n  \\n  /* .benchmark_tooltip:after {\\n      content: \\\" \\\";\\n      position: absolute;\\n      top: 50%;\\n      right: 100%;\\n      margin-top: -10px;\\n      border-width: 10px;\\n      border-style: solid;\\n      border-color: transparent transparent transparent transparent;\\n      \\n  } */\\n  \\n   .plot-bg {\\n     fill:#F8F8F8;\\n     stroke: black;\\n   }\\n      \\n   .axis path,\\n   .axis line {\\n       fill: none;\\n       stroke: grey;\\n       stroke-width: 1;\\n       shape-rendering: crispEdges;\\n   }\\n\\n   .bench_grid {\\n    stroke-opacity: 0.1;\\n    stroke-dasharray: 7,5;\\n  }\\n\\n    \\n    .classificators_list{\\n        background-color: #0A58A2; \\n        border-radius: 8px;\\n        color: #fff;\\n        font-size: 1vw;\\n        padding-left: 25px;\\n        padding-right: 25px;\\n        text-align: center;\\n        width: 20vw;\\n    \\n        }\\n    \\n    .classificators_list:hover {\\n        background-color: #b3cde0;\\n    \\n    }\\n\\n    .benchmarkingTable_scatter td {\\n        border: 2px solid black;\\n        border-collapse: collapse;\\n        text-align: center;\\n        font-size: .8vw;\\n    }\\n\\n    .benchmarkingTable_scatter {\\n        order:2;\\n        width: 18vw; \\n        border-collapse: collapse; \\n        background-color: #f0f0f0;\\n        border: 5px solid black; \\n        /* float: right; */\\n        margin-left: 1vw;\\n    }\\n\\n    .benchmark_legend_rect {\\n        cursor: pointer;\\n    }\\n\\n    .benchmarkingChart_scatter{\\n        width: inherit;\\n    }\\n\\n    .flex-container{\\n        width: 100%;\\n        display: flex;\\n        flex-wrap: wrap;\\n        justify-content: flex-start;\\n    }\\n    .benchmarkingSVG{\\n        order:1;\\n        width: 60vw;\\n    }\\n      .axis--x {\\n          font-size: 12px;\\n      }\\n\\n      .axis--y {\\n        font-size: 12px;\\n    }\\n\\n    .removal_alert {\\n        padding: 10px;\\n        background-color: #ffcccc;\\n        color: #D10000;\\n    }\\n    \\n    .closebtn {\\n        margin-left: 15px;\\n        color: #D10000;\\n        font-weight: bold;\\n        float: right;\\n        font-size: 22px;\\n        line-height: 20px;\\n        cursor: pointer;\\n        transition: 0.3s;\\n    }\\n    \\n    .closebtn:hover {\\n        color: white;\\n    }\\n\\n    .OEB_text_link {\\n        cursor: pointer;\\n        fill:#0000EE;\\n    };\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9zcmMvYXBwLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAuY3NzPzg4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4gIC5lcnJvci1saW5lIHtcXG4gICAgc3Ryb2tlOmJsYWNrO1xcbiAgICBzdHJva2UtZGFzaGFycmF5OiAyLDI7XFxuICB9XFxuICBcXG4gIC5lcnJvci1jYXAge1xcbiAgICBzdHJva2U6YmxhY2s7XFxuICAgIHN0cm9rZS13aWR0aDogMXB4O1xcbiAgfVxcbiAgXFxuICAgIGRpdi5iZW5jaG1hcmtfdG9vbHRpcCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICBwYWRkaW5nOiA3cHg7XFxuICAgICAgdGV4dC1zaGFkb3c6ICNmNWY1ZjUgMCAxcHggMDtcXG4gICAgICBmb250OiAxNXB4IEhlbHZldGljYSBOZXVlO1xcbiAgICAgIGJvcmRlcjogNC41cHggc29saWQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjMEE1OEEyO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgICBvcGFjaXR5OiAwLjk1O1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMykgMCAxMHB4IDE1cHg7XFxuICAgICAgei1pbmRleDogMztcXG4gICAgfVxcbiAgXFxuICAvKiAuYmVuY2htYXJrX3Rvb2x0aXA6YWZ0ZXIge1xcbiAgICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgcmlnaHQ6IDEwMCU7XFxuICAgICAgbWFyZ2luLXRvcDogLTEwcHg7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAxMHB4O1xcbiAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgICBcXG4gIH0gKi9cXG4gIFxcbiAgIC5wbG90LWJnIHtcXG4gICAgIGZpbGw6I0Y4RjhGODtcXG4gICAgIHN0cm9rZTogYmxhY2s7XFxuICAgfVxcbiAgICAgIFxcbiAgIC5heGlzIHBhdGgsXFxuICAgLmF4aXMgbGluZSB7XFxuICAgICAgIGZpbGw6IG5vbmU7XFxuICAgICAgIHN0cm9rZTogZ3JleTtcXG4gICAgICAgc3Ryb2tlLXdpZHRoOiAxO1xcbiAgICAgICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7XFxuICAgfVxcblxcbiAgIC5iZW5jaF9ncmlkIHtcXG4gICAgc3Ryb2tlLW9wYWNpdHk6IDAuMTtcXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogNyw1O1xcbiAgfVxcblxcbiAgICBcXG4gICAgLmNsYXNzaWZpY2F0b3JzX2xpc3R7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMEE1OEEyOyBcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgICAgZm9udC1zaXplOiAxdnc7XFxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDI1cHg7XFxuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAyNXB4O1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgd2lkdGg6IDIwdnc7XFxuICAgIFxcbiAgICAgICAgfVxcbiAgICBcXG4gICAgLmNsYXNzaWZpY2F0b3JzX2xpc3Q6aG92ZXIge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2IzY2RlMDtcXG4gICAgXFxuICAgIH1cXG5cXG4gICAgLmJlbmNobWFya2luZ1RhYmxlX3NjYXR0ZXIgdGQge1xcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XFxuICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgZm9udC1zaXplOiAuOHZ3O1xcbiAgICB9XFxuXFxuICAgIC5iZW5jaG1hcmtpbmdUYWJsZV9zY2F0dGVyIHtcXG4gICAgICAgIG9yZGVyOjI7XFxuICAgICAgICB3aWR0aDogMTh2dzsgXFxuICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyBcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XFxuICAgICAgICBib3JkZXI6IDVweCBzb2xpZCBibGFjazsgXFxuICAgICAgICAvKiBmbG9hdDogcmlnaHQ7ICovXFxuICAgICAgICBtYXJnaW4tbGVmdDogMXZ3O1xcbiAgICB9XFxuXFxuICAgIC5iZW5jaG1hcmtfbGVnZW5kX3JlY3Qge1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB9XFxuXFxuICAgIC5iZW5jaG1hcmtpbmdDaGFydF9zY2F0dGVye1xcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XFxuICAgIH1cXG5cXG4gICAgLmZsZXgtY29udGFpbmVye1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICB9XFxuICAgIC5iZW5jaG1hcmtpbmdTVkd7XFxuICAgICAgICBvcmRlcjoxO1xcbiAgICAgICAgd2lkdGg6IDYwdnc7XFxuICAgIH1cXG4gICAgICAuYXhpcy0teCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICB9XFxuXFxuICAgICAgLmF4aXMtLXkge1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICB9XFxuXFxuICAgIC5yZW1vdmFsX2FsZXJ0IHtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZjY2NjO1xcbiAgICAgICAgY29sb3I6ICNEMTAwMDA7XFxuICAgIH1cXG4gICAgXFxuICAgIC5jbG9zZWJ0biB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMTVweDtcXG4gICAgICAgIGNvbG9yOiAjRDEwMDAwO1xcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgICAgICBmbG9hdDogcmlnaHQ7XFxuICAgICAgICBmb250LXNpemU6IDIycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgIHRyYW5zaXRpb246IDAuM3M7XFxuICAgIH1cXG4gICAgXFxuICAgIC5jbG9zZWJ0bjpob3ZlciB7XFxuICAgICAgICBjb2xvcjogd2hpdGU7XFxuICAgIH1cXG5cXG4gICAgLk9FQl90ZXh0X2xpbmsge1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgZmlsbDojMDAwMEVFO1xcbiAgICB9O1xcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./src/app.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/area.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-polygon/src/area.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvYXJlYS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1wb2x5Z29uL3NyYy9hcmVhLmpzPzlmZTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9seWdvbikge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgYSxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIGFyZWEgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYSA9IGI7XG4gICAgYiA9IHBvbHlnb25baV07XG4gICAgYXJlYSArPSBhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdO1xuICB9XG5cbiAgcmV0dXJuIGFyZWEgLyAyO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/area.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/centroid.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-polygon/src/centroid.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY2VudHJvaWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY2VudHJvaWQuanM/MWY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgYSxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIGMsXG4gICAgICBrID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEgPSBiO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIGsgKz0gYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBjO1xuICB9XG5cbiAgcmV0dXJuIGsgKj0gMywgW3ggLyBrLCB5IC8ga107XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/centroid.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/contains.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-polygon/src/contains.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY29udGFpbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY29udGFpbnMuanM/Yjk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgcCA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgeCA9IHBvaW50WzBdLCB5ID0gcG9pbnRbMV0sXG4gICAgICB4MCA9IHBbMF0sIHkwID0gcFsxXSxcbiAgICAgIHgxLCB5MSxcbiAgICAgIGluc2lkZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IHBvbHlnb25baV0sIHgxID0gcFswXSwgeTEgPSBwWzFdO1xuICAgIGlmICgoKHkxID4geSkgIT09ICh5MCA+IHkpKSAmJiAoeCA8ICh4MCAtIHgxKSAqICh5IC0geTEpIC8gKHkwIC0geTEpICsgeDEpKSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIHgwID0geDEsIHkwID0geTE7XG4gIH1cblxuICByZXR1cm4gaW5zaWRlO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/contains.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/cross.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-polygon/src/cross.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY3Jvc3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvY3Jvc3MuanM/MzBiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZXR1cm5zIHRoZSAyRCBjcm9zcyBwcm9kdWN0IG9mIEFCIGFuZCBBQyB2ZWN0b3JzLCBpLmUuLCB0aGUgei1jb21wb25lbnQgb2Zcbi8vIHRoZSAzRCBjcm9zcyBwcm9kdWN0IGluIGEgcXVhZHJhbnQgSSBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW0gKCt4IGlzXG4vLyByaWdodCwgK3kgaXMgdXApLiBSZXR1cm5zIGEgcG9zaXRpdmUgdmFsdWUgaWYgQUJDIGlzIGNvdW50ZXItY2xvY2t3aXNlLFxuLy8gbmVnYXRpdmUgaWYgY2xvY2t3aXNlLCBhbmQgemVybyBpZiB0aGUgcG9pbnRzIGFyZSBjb2xsaW5lYXIuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/cross.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/hull.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-polygon/src/hull.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cross */ \"./node_modules/d3-polygon/src/cross.js\");\n\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && Object(_cross__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvaHVsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1wb2x5Z29uL3NyYy9odWxsLmpzPzdiM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyb3NzIGZyb20gXCIuL2Nyb3NzXCI7XG5cbmZ1bmN0aW9uIGxleGljb2dyYXBoaWNPcmRlcihhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXTtcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIHVwcGVyIGNvbnZleCBodWxsIHBlciB0aGUgbW9ub3RvbmUgY2hhaW4gYWxnb3JpdGhtLlxuLy8gQXNzdW1lcyBwb2ludHMubGVuZ3RoID49IDMsIGlzIHNvcnRlZCBieSB4LCB1bmlxdWUgaW4geS5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgaW5kaWNlcyBpbnRvIHBvaW50cyBpbiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLlxuZnVuY3Rpb24gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgIGluZGV4ZXMgPSBbMCwgMV0sXG4gICAgICBzaXplID0gMjtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IG47ICsraSkge1xuICAgIHdoaWxlIChzaXplID4gMSAmJiBjcm9zcyhwb2ludHNbaW5kZXhlc1tzaXplIC0gMl1dLCBwb2ludHNbaW5kZXhlc1tzaXplIC0gMV1dLCBwb2ludHNbaV0pIDw9IDApIC0tc2l6ZTtcbiAgICBpbmRleGVzW3NpemUrK10gPSBpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXMuc2xpY2UoMCwgc2l6ZSk7IC8vIHJlbW92ZSBwb3BwZWQgcG9pbnRzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvaW50cykge1xuICBpZiAoKG4gPSBwb2ludHMubGVuZ3RoKSA8IDMpIHJldHVybiBudWxsO1xuXG4gIHZhciBpLFxuICAgICAgbixcbiAgICAgIHNvcnRlZFBvaW50cyA9IG5ldyBBcnJheShuKSxcbiAgICAgIGZsaXBwZWRQb2ludHMgPSBuZXcgQXJyYXkobik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc29ydGVkUG9pbnRzW2ldID0gWytwb2ludHNbaV1bMF0sICtwb2ludHNbaV1bMV0sIGldO1xuICBzb3J0ZWRQb2ludHMuc29ydChsZXhpY29ncmFwaGljT3JkZXIpO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBmbGlwcGVkUG9pbnRzW2ldID0gW3NvcnRlZFBvaW50c1tpXVswXSwgLXNvcnRlZFBvaW50c1tpXVsxXV07XG5cbiAgdmFyIHVwcGVySW5kZXhlcyA9IGNvbXB1dGVVcHBlckh1bGxJbmRleGVzKHNvcnRlZFBvaW50cyksXG4gICAgICBsb3dlckluZGV4ZXMgPSBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhmbGlwcGVkUG9pbnRzKTtcblxuICAvLyBDb25zdHJ1Y3QgdGhlIGh1bGwgcG9seWdvbiwgcmVtb3ZpbmcgcG9zc2libGUgZHVwbGljYXRlIGVuZHBvaW50cy5cbiAgdmFyIHNraXBMZWZ0ID0gbG93ZXJJbmRleGVzWzBdID09PSB1cHBlckluZGV4ZXNbMF0sXG4gICAgICBza2lwUmlnaHQgPSBsb3dlckluZGV4ZXNbbG93ZXJJbmRleGVzLmxlbmd0aCAtIDFdID09PSB1cHBlckluZGV4ZXNbdXBwZXJJbmRleGVzLmxlbmd0aCAtIDFdLFxuICAgICAgaHVsbCA9IFtdO1xuXG4gIC8vIEFkZCB1cHBlciBodWxsIGluIHJpZ2h0LXRvLWwgb3JkZXIuXG4gIC8vIFRoZW4gYWRkIGxvd2VyIGh1bGwgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAgZm9yIChpID0gdXBwZXJJbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBodWxsLnB1c2gocG9pbnRzW3NvcnRlZFBvaW50c1t1cHBlckluZGV4ZXNbaV1dWzJdXSk7XG4gIGZvciAoaSA9ICtza2lwTGVmdDsgaSA8IGxvd2VySW5kZXhlcy5sZW5ndGggLSBza2lwUmlnaHQ7ICsraSkgaHVsbC5wdXNoKHBvaW50c1tzb3J0ZWRQb2ludHNbbG93ZXJJbmRleGVzW2ldXVsyXV0pO1xuXG4gIHJldHVybiBodWxsO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/hull.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-polygon/src/index.js ***!
  \**********************************************/
/*! exports provided: polygonArea, polygonCentroid, polygonHull, polygonContains, polygonLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area */ \"./node_modules/d3-polygon/src/area.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polygonArea\", function() { return _area__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./centroid */ \"./node_modules/d3-polygon/src/centroid.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polygonCentroid\", function() { return _centroid__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _hull__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hull */ \"./node_modules/d3-polygon/src/hull.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polygonHull\", function() { return _hull__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains */ \"./node_modules/d3-polygon/src/contains.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polygonContains\", function() { return _contains__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./length */ \"./node_modules/d3-polygon/src/length.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polygonLength\", function() { return _length__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvaW5kZXguanM/YjU0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge2RlZmF1bHQgYXMgcG9seWdvbkFyZWF9IGZyb20gXCIuL2FyZWFcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2x5Z29uQ2VudHJvaWR9IGZyb20gXCIuL2NlbnRyb2lkXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcG9seWdvbkh1bGx9IGZyb20gXCIuL2h1bGxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2x5Z29uQ29udGFpbnN9IGZyb20gXCIuL2NvbnRhaW5zXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcG9seWdvbkxlbmd0aH0gZnJvbSBcIi4vbGVuZ3RoXCI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/index.js\n");

/***/ }),

/***/ "./node_modules/d3-polygon/src/length.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-polygon/src/length.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.sqrt(xa * xa + ya * ya);\n  }\n\n  return perimeter;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZDMtcG9seWdvbi9zcmMvbGVuZ3RoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXBvbHlnb24vc3JjL2xlbmd0aC5qcz8yMGQ5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIHhhLFxuICAgICAgeWEsXG4gICAgICB4YiA9IGJbMF0sXG4gICAgICB5YiA9IGJbMV0sXG4gICAgICBwZXJpbWV0ZXIgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgeGEgPSB4YjtcbiAgICB5YSA9IHliO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIHhiID0gYlswXTtcbiAgICB5YiA9IGJbMV07XG4gICAgeGEgLT0geGI7XG4gICAgeWEgLT0geWI7XG4gICAgcGVyaW1ldGVyICs9IE1hdGguc3FydCh4YSAqIHhhICsgeWEgKiB5YSk7XG4gIH1cblxuICByZXR1cm4gcGVyaW1ldGVyO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/d3-polygon/src/length.js\n");

/***/ }),

/***/ "./node_modules/pareto-frontier/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pareto-frontier/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst pointComparators = Object.freeze({\n    topRight:    (a, b) => (b[0] < a[0] ? -1 : (b[0] > a[0] ? 1 : (b[1] < a[1] ? -1 : (b[1] > a[1] ? 1 : 0)))),\n    topLeft:     (a, b) => (a[0] < b[0] ? -1 : (a[0] > b[0] ? 1 : (a[1] < b[1] ? 1 : (a[1] > b[1] ? -1 : 0)))),\n    bottomRight: (a, b) => (b[0] < a[0] ? -1 : (b[0] > a[0] ? 1 : (b[1] < a[1] ? 1 : (b[1] > a[1] ? -1 : 0)))),\n    bottomLeft:  (a, b) => (a[0] < b[0] ? -1 : (a[0] > b[0] ? 1 : (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0)))),\n});\n\nconst getParetoFrontier = (points, options) => {\n    if (!Array.isArray(points) || !points.every(p => Array.isArray(p) && p.length >= 2)) { throw new TypeError('Require array of points as input'); }\n\n    const pointComparator = options && pointComparators[options.optimize] || pointComparators.topRight;\n    const findMax = (pointComparator([0, 1], [0, 0]) < 0); // Optimize +y\n\n    let last;\n    return Array.from(points).sort(pointComparator).filter((p, i) => {\n        if (i === 0 || findMax && p[1] > last || !findMax && p[1] < last) { last = p[1]; return true; }\n\n        return false;\n    });\n}\n\nexports.getParetoFrontier = getParetoFrontier;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFyZXRvLWZyb250aWVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcmV0by1mcm9udGllci9pbmRleC5qcz9kYWY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcG9pbnRDb21wYXJhdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRvcFJpZ2h0OiAgICAoYSwgYikgPT4gKGJbMF0gPCBhWzBdID8gLTEgOiAoYlswXSA+IGFbMF0gPyAxIDogKGJbMV0gPCBhWzFdID8gLTEgOiAoYlsxXSA+IGFbMV0gPyAxIDogMCkpKSksXG4gICAgdG9wTGVmdDogICAgIChhLCBiKSA9PiAoYVswXSA8IGJbMF0gPyAtMSA6IChhWzBdID4gYlswXSA/IDEgOiAoYVsxXSA8IGJbMV0gPyAxIDogKGFbMV0gPiBiWzFdID8gLTEgOiAwKSkpKSxcbiAgICBib3R0b21SaWdodDogKGEsIGIpID0+IChiWzBdIDwgYVswXSA/IC0xIDogKGJbMF0gPiBhWzBdID8gMSA6IChiWzFdIDwgYVsxXSA/IDEgOiAoYlsxXSA+IGFbMV0gPyAtMSA6IDApKSkpLFxuICAgIGJvdHRvbUxlZnQ6ICAoYSwgYikgPT4gKGFbMF0gPCBiWzBdID8gLTEgOiAoYVswXSA+IGJbMF0gPyAxIDogKGFbMV0gPCBiWzFdID8gLTEgOiAoYVsxXSA+IGJbMV0gPyAxIDogMCkpKSksXG59KTtcblxuY29uc3QgZ2V0UGFyZXRvRnJvbnRpZXIgPSAocG9pbnRzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykgfHwgIXBvaW50cy5ldmVyeShwID0+IEFycmF5LmlzQXJyYXkocCkgJiYgcC5sZW5ndGggPj0gMikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWlyZSBhcnJheSBvZiBwb2ludHMgYXMgaW5wdXQnKTsgfVxuXG4gICAgY29uc3QgcG9pbnRDb21wYXJhdG9yID0gb3B0aW9ucyAmJiBwb2ludENvbXBhcmF0b3JzW29wdGlvbnMub3B0aW1pemVdIHx8IHBvaW50Q29tcGFyYXRvcnMudG9wUmlnaHQ7XG4gICAgY29uc3QgZmluZE1heCA9IChwb2ludENvbXBhcmF0b3IoWzAsIDFdLCBbMCwgMF0pIDwgMCk7IC8vIE9wdGltaXplICt5XG5cbiAgICBsZXQgbGFzdDtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwb2ludHMpLnNvcnQocG9pbnRDb21wYXJhdG9yKS5maWx0ZXIoKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgZmluZE1heCAmJiBwWzFdID4gbGFzdCB8fCAhZmluZE1heCAmJiBwWzFdIDwgbGFzdCkgeyBsYXN0ID0gcFsxXTsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuZ2V0UGFyZXRvRnJvbnRpZXIgPSBnZXRQYXJldG9Gcm9udGllcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pareto-frontier/index.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./src/app.css":
/*!*********************!*\
  !*** ./src/app.css ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader??ref--4-1!./app.css */ \"./node_modules/css-loader/index.js?!./src/app.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAuY3NzP2U2N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTQtMSEuL2FwcC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTQtMSEuL2FwcC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi9hcHAuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app.css\n");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! exports provided: load_scatter_visualization, onQuartileChange, better */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load_scatter_visualization\", function() { return load_scatter_visualization; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onQuartileChange\", function() { return onQuartileChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"better\", function() { return better; });\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.css */ \"./src/app.css\");\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var apollo_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-fetch */ \"./node_modules/apollo-fetch/dist/index.js\");\n/* harmony import */ var _selection_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selection_list */ \"./src/selection_list.js\");\n/* harmony import */ var _scatter_plot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scatter_plot */ \"./src/scatter_plot.js\");\n\n\n\n\n\n// ./node_modules/.bin/webpack-cli src/app.js --output=build/build.js -d -w\n\n\nlet MAIN_DATA = {};\nlet MAIN_METRICS = {};\nlet better = {};\n\n\nfunction load_scatter_visualization(){\n\n    \n    let divid;\n    \n    let charts = document.getElementsByClassName(\"benchmarkingChart_scatter\");\n     \n    let i = 0;\n    let dataId;\n    let y;\n    \n    // append ids to chart/s and make d3 plot\n    i = 0\n    for(y of charts){\n\n      // define base url - production or development\n      //check for mode by default it is production if no param is given\n      var mode = $(y).data(\"mode\") ? \"dev-openebench\" : \"openebench\"\n      let base_url = \"https://\" + mode + \".bsc.es/\";\n\n      // get benchmarking event id\n      dataId = y.getAttribute('data-id');\n\n      //set chart id\n      divid = (dataId+i).replace(\":\",\"_\");\n      y.id=divid;\n\n      //append selection list\n      Object(_selection_list__WEBPACK_IMPORTED_MODULE_2__[\"append_classifiers_list\"])(divid);\n      let url = base_url + \"sciapi/graphql\";\n      \n      let json_query = `query getDatasets($dataset_id: String!){\n                          getDatasets(datasetFilters:{id: $dataset_id, type:\"aggregation\"}) {\n                              _id\n                              community_ids\n                              datalink{\n                                  inline_data\n                              }\n                          }\n                        }`\n\n      get_data(url, json_query, dataId, divid); \n\n\n      //check the transformation to table attribute and append table to html\n      if (y.getAttribute('toTable') == \"true\"){\n        let table_id = divid + \"_table\";\n        var input = $('<br><br><table id=\"'+table_id+'\" data-id=\"'+dataId+'\" class=\"benchmarkingTable_scatter\"></table>');\n        $(\"#\" + divid + \"flex-container\").append(input);\n      };\n            \n      i++;\n    }\n        \n    \n       \n};\n\n\n\nfunction get_data(url, json_query ,dataId, divid){\n\n  try {\n\n      const fetch = Object(apollo_fetch__WEBPACK_IMPORTED_MODULE_1__[\"createApolloFetch\"])({\n        uri: url,\n      });\n\n      let vars = { dataset_id: dataId };\n\n      fetch({\n        query: json_query,\n        variables: vars,\n      }).then(res => {\n          let result = res.data.getDatasets;\n          if (result.length == 0){\n\n            document.getElementById(divid + \"_dropdown_list\").remove();\n      \n            var para = document.createElement(\"td\");\n            para.id = \"no_benchmark_data\"\n            var err_txt = document.createTextNode(\"No data available for the selected challenge: \" + dataId);\n            para.appendChild(err_txt);\n            var element = document.getElementById(divid);\n            element.appendChild(para);\n      \n        } else {\n\n          // get the names of the tools that are present in the community\n          const fetchData = () => fetch({\n            query: `query getMetrics{\n                        getMetrics {\n                          _id\n                          title\n                          representation_hints\n                        }\n                    }`\n          });\n          \n          fetchData().then(response => { \n            \n            let metrics_list = response.data.getMetrics;\n          \n            // iterate over the list of metrics to generate a dictionary\n            let metrics_names = {};\n            let metrics_representation = {};\n            metrics_list.forEach( function(element) {\n              metrics_names[element._id] = element.title\n              \n            });\n            // get optimization point\n            if (result[0].datalink.inline_data.visualization.optimization == \"bottom-right\"){\n              better[divid]= \"bottom-right\";\n            } else {\n              better[divid]= \"top-right\";\n            };\n            let metric_x = result[0].datalink.inline_data.visualization.x_axis;\n            let metric_y = result[0].datalink.inline_data.visualization.y_axis;\n            // append those metrics as div attributes, so that they cna be used later\n            document.getElementById(divid).setAttribute(\"metric_x\", metric_x); \n            document.getElementById(divid).setAttribute(\"metric_y\", metric_y);\n            join_all_json(result, divid, metric_x, metric_y,metrics_names, better);\n\n          } );\n          \n        };\n      });\n\n    }\n    catch (err) {\n      console.log(`Invalid Url Error: ${err.stack} `);\n    }\n\n};\n\n\n\nfunction join_all_json(result, divid, metric_x, metric_y,metrics_names, better){\n  try{\n\n    // transform the object to an array, which is usable by the D3 chart\n    let full_json = [];\n    result[0].datalink.inline_data.challenge_participants.forEach( function(element) {\n\n      //if participant name is too long, slice it\n      let tool_name = element.tool_id;\n      var short_name;\n      if (tool_name.length > 22){\n        short_name = tool_name.substring(0,22);\n      } else {\n        short_name = tool_name\n      }\n\n      let jo = {};\n      jo['toolname'] = short_name;\n      jo['x'] = element.metric_x;\n      jo['y'] = element.metric_y;\n      jo['e_y'] = element.stderr_y ? parseFloat(element.stderr_y) : 0;\n      jo['e_x'] = element.stderr_x ? parseFloat(element.stderr_x) : 0;\n      full_json.push(jo); \n\n    });\n\n    MAIN_DATA[divid] = full_json;\n    MAIN_METRICS[divid] = metrics_names;\n    // by default, no classification method is applied. it is the first item in the selection list\n    var e = document.getElementById(divid + \"_dropdown_list\");\n    let classification_type = e.options[e.selectedIndex].id;\n\n    Object(_scatter_plot__WEBPACK_IMPORTED_MODULE_3__[\"createChart\"])(full_json,divid, classification_type, metric_x, metric_y,metrics_names, better);\n  } catch(err){\n    console.log(`Invalid Url Error: ${err.stack} `);\n  }\n\n    \n};\n\n\nfunction onQuartileChange(ID, metric_x, metric_y, better){  \n  \n  var chart_id = ID.split(\"__\")[0];\n  // console.log(d3.select('#'+'svg_'+chart_id));\n  d3.select('#'+'svg_'+chart_id).remove();\n  let classification_type = ID;\n\n  Object(_scatter_plot__WEBPACK_IMPORTED_MODULE_3__[\"createChart\"])(MAIN_DATA[chart_id],chart_id, classification_type, metric_x, metric_y, MAIN_METRICS[chart_id], better);\n  \n};\n\n\n\n\nload_scatter_visualization();\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5qcz8xMTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9hcHAuY3NzJztcbmltcG9ydCB7IGNyZWF0ZUFwb2xsb0ZldGNoIH0gZnJvbSAnYXBvbGxvLWZldGNoJztcbmltcG9ydCB7IGFwcGVuZF9jbGFzc2lmaWVyc19saXN0IH0gZnJvbSBcIi4vc2VsZWN0aW9uX2xpc3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSBcIi4vc2NhdHRlcl9wbG90XCJcblxuLy8gLi9ub2RlX21vZHVsZXMvLmJpbi93ZWJwYWNrLWNsaSBzcmMvYXBwLmpzIC0tb3V0cHV0PWJ1aWxkL2J1aWxkLmpzIC1kIC13XG5cblxubGV0IE1BSU5fREFUQSA9IHt9O1xubGV0IE1BSU5fTUVUUklDUyA9IHt9O1xubGV0IGJldHRlciA9IHt9O1xuXG5cbmZ1bmN0aW9uIGxvYWRfc2NhdHRlcl92aXN1YWxpemF0aW9uKCl7XG5cbiAgICBcbiAgICBsZXQgZGl2aWQ7XG4gICAgXG4gICAgbGV0IGNoYXJ0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJiZW5jaG1hcmtpbmdDaGFydF9zY2F0dGVyXCIpO1xuICAgICBcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGRhdGFJZDtcbiAgICBsZXQgeTtcbiAgICBcbiAgICAvLyBhcHBlbmQgaWRzIHRvIGNoYXJ0L3MgYW5kIG1ha2UgZDMgcGxvdFxuICAgIGkgPSAwXG4gICAgZm9yKHkgb2YgY2hhcnRzKXtcblxuICAgICAgLy8gZGVmaW5lIGJhc2UgdXJsIC0gcHJvZHVjdGlvbiBvciBkZXZlbG9wbWVudFxuICAgICAgLy9jaGVjayBmb3IgbW9kZSBieSBkZWZhdWx0IGl0IGlzIHByb2R1Y3Rpb24gaWYgbm8gcGFyYW0gaXMgZ2l2ZW5cbiAgICAgIHZhciBtb2RlID0gJCh5KS5kYXRhKFwibW9kZVwiKSA/IFwiZGV2LW9wZW5lYmVuY2hcIiA6IFwib3BlbmViZW5jaFwiXG4gICAgICBsZXQgYmFzZV91cmwgPSBcImh0dHBzOi8vXCIgKyBtb2RlICsgXCIuYnNjLmVzL1wiO1xuXG4gICAgICAvLyBnZXQgYmVuY2htYXJraW5nIGV2ZW50IGlkXG4gICAgICBkYXRhSWQgPSB5LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuXG4gICAgICAvL3NldCBjaGFydCBpZFxuICAgICAgZGl2aWQgPSAoZGF0YUlkK2kpLnJlcGxhY2UoXCI6XCIsXCJfXCIpO1xuICAgICAgeS5pZD1kaXZpZDtcblxuICAgICAgLy9hcHBlbmQgc2VsZWN0aW9uIGxpc3RcbiAgICAgIGFwcGVuZF9jbGFzc2lmaWVyc19saXN0KGRpdmlkKTtcbiAgICAgIGxldCB1cmwgPSBiYXNlX3VybCArIFwic2NpYXBpL2dyYXBocWxcIjtcbiAgICAgIFxuICAgICAgbGV0IGpzb25fcXVlcnkgPSBgcXVlcnkgZ2V0RGF0YXNldHMoJGRhdGFzZXRfaWQ6IFN0cmluZyEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXREYXRhc2V0cyhkYXRhc2V0RmlsdGVyczp7aWQ6ICRkYXRhc2V0X2lkLCB0eXBlOlwiYWdncmVnYXRpb25cIn0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbXVuaXR5X2lkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YWxpbmt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lX2RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfWBcblxuICAgICAgZ2V0X2RhdGEodXJsLCBqc29uX3F1ZXJ5LCBkYXRhSWQsIGRpdmlkKTsgXG5cblxuICAgICAgLy9jaGVjayB0aGUgdHJhbnNmb3JtYXRpb24gdG8gdGFibGUgYXR0cmlidXRlIGFuZCBhcHBlbmQgdGFibGUgdG8gaHRtbFxuICAgICAgaWYgKHkuZ2V0QXR0cmlidXRlKCd0b1RhYmxlJykgPT0gXCJ0cnVlXCIpe1xuICAgICAgICBsZXQgdGFibGVfaWQgPSBkaXZpZCArIFwiX3RhYmxlXCI7XG4gICAgICAgIHZhciBpbnB1dCA9ICQoJzxicj48YnI+PHRhYmxlIGlkPVwiJyt0YWJsZV9pZCsnXCIgZGF0YS1pZD1cIicrZGF0YUlkKydcIiBjbGFzcz1cImJlbmNobWFya2luZ1RhYmxlX3NjYXR0ZXJcIj48L3RhYmxlPicpO1xuICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcImZsZXgtY29udGFpbmVyXCIpLmFwcGVuZChpbnB1dCk7XG4gICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICBpKys7XG4gICAgfVxuICAgICAgICBcbiAgICBcbiAgICAgICBcbn07XG5cblxuXG5mdW5jdGlvbiBnZXRfZGF0YSh1cmwsIGpzb25fcXVlcnkgLGRhdGFJZCwgZGl2aWQpe1xuXG4gIHRyeSB7XG5cbiAgICAgIGNvbnN0IGZldGNoID0gY3JlYXRlQXBvbGxvRmV0Y2goe1xuICAgICAgICB1cmk6IHVybCxcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgdmFycyA9IHsgZGF0YXNldF9pZDogZGF0YUlkIH07XG5cbiAgICAgIGZldGNoKHtcbiAgICAgICAgcXVlcnk6IGpzb25fcXVlcnksXG4gICAgICAgIHZhcmlhYmxlczogdmFycyxcbiAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVzLmRhdGEuZ2V0RGF0YXNldHM7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMCl7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkICsgXCJfZHJvcGRvd25fbGlzdFwiKS5yZW1vdmUoKTtcbiAgICAgIFxuICAgICAgICAgICAgdmFyIHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICBwYXJhLmlkID0gXCJub19iZW5jaG1hcmtfZGF0YVwiXG4gICAgICAgICAgICB2YXIgZXJyX3R4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoZSBzZWxlY3RlZCBjaGFsbGVuZ2U6IFwiICsgZGF0YUlkKTtcbiAgICAgICAgICAgIHBhcmEuYXBwZW5kQ2hpbGQoZXJyX3R4dCk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocGFyYSk7XG4gICAgICBcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIGdldCB0aGUgbmFtZXMgb2YgdGhlIHRvb2xzIHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIGNvbW11bml0eVxuICAgICAgICAgIGNvbnN0IGZldGNoRGF0YSA9ICgpID0+IGZldGNoKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBgcXVlcnkgZ2V0TWV0cmljc3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE1ldHJpY3Mge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcmVzZW50YXRpb25faGludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBmZXRjaERhdGEoKS50aGVuKHJlc3BvbnNlID0+IHsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBtZXRyaWNzX2xpc3QgPSByZXNwb25zZS5kYXRhLmdldE1ldHJpY3M7XG4gICAgICAgICAgXG4gICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGxpc3Qgb2YgbWV0cmljcyB0byBnZW5lcmF0ZSBhIGRpY3Rpb25hcnlcbiAgICAgICAgICAgIGxldCBtZXRyaWNzX25hbWVzID0ge307XG4gICAgICAgICAgICBsZXQgbWV0cmljc19yZXByZXNlbnRhdGlvbiA9IHt9O1xuICAgICAgICAgICAgbWV0cmljc19saXN0LmZvckVhY2goIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgbWV0cmljc19uYW1lc1tlbGVtZW50Ll9pZF0gPSBlbGVtZW50LnRpdGxlXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBnZXQgb3B0aW1pemF0aW9uIHBvaW50XG4gICAgICAgICAgICBpZiAocmVzdWx0WzBdLmRhdGFsaW5rLmlubGluZV9kYXRhLnZpc3VhbGl6YXRpb24ub3B0aW1pemF0aW9uID09IFwiYm90dG9tLXJpZ2h0XCIpe1xuICAgICAgICAgICAgICBiZXR0ZXJbZGl2aWRdPSBcImJvdHRvbS1yaWdodFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmV0dGVyW2RpdmlkXT0gXCJ0b3AtcmlnaHRcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbWV0cmljX3ggPSByZXN1bHRbMF0uZGF0YWxpbmsuaW5saW5lX2RhdGEudmlzdWFsaXphdGlvbi54X2F4aXM7XG4gICAgICAgICAgICBsZXQgbWV0cmljX3kgPSByZXN1bHRbMF0uZGF0YWxpbmsuaW5saW5lX2RhdGEudmlzdWFsaXphdGlvbi55X2F4aXM7XG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhvc2UgbWV0cmljcyBhcyBkaXYgYXR0cmlidXRlcywgc28gdGhhdCB0aGV5IGNuYSBiZSB1c2VkIGxhdGVyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXZpZCkuc2V0QXR0cmlidXRlKFwibWV0cmljX3hcIiwgbWV0cmljX3gpOyBcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkKS5zZXRBdHRyaWJ1dGUoXCJtZXRyaWNfeVwiLCBtZXRyaWNfeSk7XG4gICAgICAgICAgICBqb2luX2FsbF9qc29uKHJlc3VsdCwgZGl2aWQsIG1ldHJpY194LCBtZXRyaWNfeSxtZXRyaWNzX25hbWVzLCBiZXR0ZXIpO1xuXG4gICAgICAgICAgfSApO1xuICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coYEludmFsaWQgVXJsIEVycm9yOiAke2Vyci5zdGFja30gYCk7XG4gICAgfVxuXG59O1xuXG5cblxuZnVuY3Rpb24gam9pbl9hbGxfanNvbihyZXN1bHQsIGRpdmlkLCBtZXRyaWNfeCwgbWV0cmljX3ksbWV0cmljc19uYW1lcywgYmV0dGVyKXtcbiAgdHJ5e1xuXG4gICAgLy8gdHJhbnNmb3JtIHRoZSBvYmplY3QgdG8gYW4gYXJyYXksIHdoaWNoIGlzIHVzYWJsZSBieSB0aGUgRDMgY2hhcnRcbiAgICBsZXQgZnVsbF9qc29uID0gW107XG4gICAgcmVzdWx0WzBdLmRhdGFsaW5rLmlubGluZV9kYXRhLmNoYWxsZW5nZV9wYXJ0aWNpcGFudHMuZm9yRWFjaCggZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgICAvL2lmIHBhcnRpY2lwYW50IG5hbWUgaXMgdG9vIGxvbmcsIHNsaWNlIGl0XG4gICAgICBsZXQgdG9vbF9uYW1lID0gZWxlbWVudC50b29sX2lkO1xuICAgICAgdmFyIHNob3J0X25hbWU7XG4gICAgICBpZiAodG9vbF9uYW1lLmxlbmd0aCA+IDIyKXtcbiAgICAgICAgc2hvcnRfbmFtZSA9IHRvb2xfbmFtZS5zdWJzdHJpbmcoMCwyMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG9ydF9uYW1lID0gdG9vbF9uYW1lXG4gICAgICB9XG5cbiAgICAgIGxldCBqbyA9IHt9O1xuICAgICAgam9bJ3Rvb2xuYW1lJ10gPSBzaG9ydF9uYW1lO1xuICAgICAgam9bJ3gnXSA9IGVsZW1lbnQubWV0cmljX3g7XG4gICAgICBqb1sneSddID0gZWxlbWVudC5tZXRyaWNfeTtcbiAgICAgIGpvWydlX3knXSA9IGVsZW1lbnQuc3RkZXJyX3kgPyBwYXJzZUZsb2F0KGVsZW1lbnQuc3RkZXJyX3kpIDogMDtcbiAgICAgIGpvWydlX3gnXSA9IGVsZW1lbnQuc3RkZXJyX3ggPyBwYXJzZUZsb2F0KGVsZW1lbnQuc3RkZXJyX3gpIDogMDtcbiAgICAgIGZ1bGxfanNvbi5wdXNoKGpvKTsgXG5cbiAgICB9KTtcblxuICAgIE1BSU5fREFUQVtkaXZpZF0gPSBmdWxsX2pzb247XG4gICAgTUFJTl9NRVRSSUNTW2RpdmlkXSA9IG1ldHJpY3NfbmFtZXM7XG4gICAgLy8gYnkgZGVmYXVsdCwgbm8gY2xhc3NpZmljYXRpb24gbWV0aG9kIGlzIGFwcGxpZWQuIGl0IGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZWxlY3Rpb24gbGlzdFxuICAgIHZhciBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQgKyBcIl9kcm9wZG93bl9saXN0XCIpO1xuICAgIGxldCBjbGFzc2lmaWNhdGlvbl90eXBlID0gZS5vcHRpb25zW2Uuc2VsZWN0ZWRJbmRleF0uaWQ7XG5cbiAgICBjcmVhdGVDaGFydChmdWxsX2pzb24sZGl2aWQsIGNsYXNzaWZpY2F0aW9uX3R5cGUsIG1ldHJpY194LCBtZXRyaWNfeSxtZXRyaWNzX25hbWVzLCBiZXR0ZXIpO1xuICB9IGNhdGNoKGVycil7XG4gICAgY29uc29sZS5sb2coYEludmFsaWQgVXJsIEVycm9yOiAke2Vyci5zdGFja30gYCk7XG4gIH1cblxuICAgIFxufTtcblxuXG5mdW5jdGlvbiBvblF1YXJ0aWxlQ2hhbmdlKElELCBtZXRyaWNfeCwgbWV0cmljX3ksIGJldHRlcil7ICBcbiAgXG4gIHZhciBjaGFydF9pZCA9IElELnNwbGl0KFwiX19cIilbMF07XG4gIC8vIGNvbnNvbGUubG9nKGQzLnNlbGVjdCgnIycrJ3N2Z18nK2NoYXJ0X2lkKSk7XG4gIGQzLnNlbGVjdCgnIycrJ3N2Z18nK2NoYXJ0X2lkKS5yZW1vdmUoKTtcbiAgbGV0IGNsYXNzaWZpY2F0aW9uX3R5cGUgPSBJRDtcblxuICBjcmVhdGVDaGFydChNQUlOX0RBVEFbY2hhcnRfaWRdLGNoYXJ0X2lkLCBjbGFzc2lmaWNhdGlvbl90eXBlLCBtZXRyaWNfeCwgbWV0cmljX3ksIE1BSU5fTUVUUklDU1tjaGFydF9pZF0sIGJldHRlcik7XG4gIFxufTtcblxuXG5leHBvcnR7XG4gIGxvYWRfc2NhdHRlcl92aXN1YWxpemF0aW9uLFxuICBvblF1YXJ0aWxlQ2hhbmdlLFxuICBiZXR0ZXJcbn1cblxubG9hZF9zY2F0dGVyX3Zpc3VhbGl6YXRpb24oKTtcblxuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app.js\n");

/***/ }),

/***/ "./src/chart_coordinates.js":
/*!**********************************!*\
  !*** ./src/chart_coordinates.js ***!
  \**********************************/
/*! exports provided: append_dots_errobars */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"append_dots_errobars\", function() { return append_dots_errobars; });\n\nfunction append_dots_errobars (svg, data, xScale, yScale, div, cValue, color,divid, metric_x, metric_y, metrics_names){\n\n  // Add Y Axis Error Line\n  svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"class\", \"error-line\")\n      .attr(\"id\", function (d) { return divid+\"___line\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"x1\", function(d) {\n        return xScale(d.x);\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y + d.e_y);\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x);\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y - d.e_y);\n      });\n\n  // Add X Axis Error Line\n  svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"class\", \"error-line\")\n      .attr(\"id\", function (d) { return divid+\"___lineX\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"x1\", function(d) {\n        return xScale(d.x - d.e_x);\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y);\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x + d.e_x);\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y);\n      });\n\n  // Add Error Top Cap\n  svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"id\", function (d) { return divid+\"___top\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"class\", \"error-cap\")\n      .attr(\"x1\", function(d) {\n        return xScale(d.x) - 4;\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y + d.e_y);\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x) + 4;\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y + d.e_y);\n      });\n\n  // Add Error Bottom Cap\n  svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"id\", function (d) { return divid+\"___bottom\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"class\", \"error-cap\")\n      .attr(\"x1\", function(d) {\n        return xScale(d.x) - 4;\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y - d.e_y);\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x) + 4;\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y - d.e_y);\n      });\n\n  // add right error cap\n  svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"class\", \"error-cap\")\n      .attr(\"id\", function (d) { return divid+\"___right\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"x1\", function(d) {\n        return xScale(d.x + d.e_x);\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y) - 4;\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x + d.e_x);\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y) + 4;\n      });\n\n    // add left error cap\n    svg.append(\"g\").selectAll(\"line\")\n      .data(data).enter()\n      .append(\"line\")\n      .attr(\"class\", \"error-cap\")\n      .attr(\"id\", function (d) { return divid+\"___left\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"x1\", function(d) {\n        return xScale(d.x - d.e_x);\n      })\n      .attr(\"y1\", function(d) {\n        return yScale(d.y) - 4;\n      })\n      .attr(\"x2\", function(d) {\n        return xScale(d.x - d.e_x);\n      })\n      .attr(\"y2\", function(d) {\n        return yScale(d.y) + 4;\n      });\n\n  // add dots\n  let symbol = d3.symbol();\n\n  let formatComma = d3.format(\",\");\n  let formatDecimal = d3.format(\".4f\");\n\n  let dots =svg.selectAll(\".dots\")\n    .data(data)\n    .enter()\n    .append(\"path\")\n    .attr(\"class\", \"benchmark_path\");\n  \n  // define the shapes of the dots\n  var symbolGenerator = d3.symbol()\n  .size(100);\n\n  var shapeScale = d3.scaleOrdinal()\n            .domain(data.map(d => d.toolname))\n            .range(Array(Math.ceil(data.length/7)).fill([d3.symbolCircle, d3.symbolCross, d3.symbolDiamond, d3.symbolSquare, d3.symbolStar, d3.symbolTriangle, d3.symbolWye]).flat());\n\n    dots.attr(\"d\", symbol.type(function(d){return shapeScale(d.toolname)}).size(120))\n      .attr(\"id\", function (d) {  return divid+\"___\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");})\n      .attr(\"class\",\"line\")\n      .attr('transform',function(d){ return \"translate(\"+xScale(d.x)+\",\"+yScale(d.y)+\")\"; })\n      .attr(\"r\", 6)\n      .style(\"fill\", function(d) {\n        return color(cValue(d));\n      })\n      .on(\"mouseover\", function(d) {\n        // show tooltip only if the tool is visible\n        let ID = divid+\"___\"+d.toolname.replace(/[\\. ()/-]/g, \"_\");\n        if (metric_x.startsWith(\"OEBM\") == true){\n          var txt_x = metrics_names[metric_x];\n        } else {\n          var txt_x = metric_x;\n        };\n        if (metric_y.startsWith(\"OEBM\") == true){\n          var txt_y = metrics_names[metric_y];\n        } else {\n          var txt_y = metric_y;\n        };\n        if (d3.select(\"#\"+ID).style(\"opacity\") == 1) {\n          div.transition()\t\t\n              .duration(100)\t\t\n              .style(\"display\",\"block\")\t\t\n              .style(\"opacity\", .9);\t\t\n          div.html(\"<b>\" + d.toolname + \"</b><br/>\"  + txt_x + \": \" + formatComma(d.x) + \"<br/>\"  + txt_y + \": \" + formatDecimal(d.y))\t\n              .style(\"left\", (d3.event.pageX) + \"px\")\t\t\n              .style(\"top\", (d3.event.pageY) + \"px\");\n        }\n      })\t\t\t\t\t\n      .on(\"mouseout\", function(d) {\t\t\n        div.transition()\t\t\n          .duration(1500)\n          .style(\"display\",\"none\")\t\t\n          .style(\"opacity\", 0);\t\n      });\n    \n    \n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnRfY29vcmRpbmF0ZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnRfY29vcmRpbmF0ZXMuanM/ZjRhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZG90c19lcnJvYmFycyAoc3ZnLCBkYXRhLCB4U2NhbGUsIHlTY2FsZSwgZGl2LCBjVmFsdWUsIGNvbG9yLGRpdmlkLCBtZXRyaWNfeCwgbWV0cmljX3ksIG1ldHJpY3NfbmFtZXMpe1xuXG4gIC8vIEFkZCBZIEF4aXMgRXJyb3IgTGluZVxuICBzdmcuYXBwZW5kKFwiZ1wiKS5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAuZGF0YShkYXRhKS5lbnRlcigpXG4gICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImVycm9yLWxpbmVcIilcbiAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fbGluZVwiK2QudG9vbG5hbWUucmVwbGFjZSgvW1xcLiAoKS8tXS9nLCBcIl9cIik7fSlcbiAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB5U2NhbGUoZC55ICsgZC5lX3kpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB5U2NhbGUoZC55IC0gZC5lX3kpO1xuICAgICAgfSk7XG5cbiAgLy8gQWRkIFggQXhpcyBFcnJvciBMaW5lXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgIC5kYXRhKGRhdGEpLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwiZXJyb3ItbGluZVwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19saW5lWFwiK2QudG9vbG5hbWUucmVwbGFjZSgvW1xcLiAoKS8tXS9nLCBcIl9cIik7fSlcbiAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCAtIGQuZV94KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLnkpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCArIGQuZV94KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLnkpO1xuICAgICAgfSk7XG5cbiAgLy8gQWRkIEVycm9yIFRvcCBDYXBcbiAgc3ZnLmFwcGVuZChcImdcIikuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgLmRhdGEoZGF0YSkuZW50ZXIoKVxuICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fdG9wXCIrZC50b29sbmFtZS5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKTt9KVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImVycm9yLWNhcFwiKVxuICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB4U2NhbGUoZC54KSAtIDQ7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB5U2NhbGUoZC55ICsgZC5lX3kpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCkgKyA0O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geVNjYWxlKGQueSArIGQuZV95KTtcbiAgICAgIH0pO1xuXG4gIC8vIEFkZCBFcnJvciBCb3R0b20gQ2FwXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgIC5kYXRhKGRhdGEpLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkaXZpZCtcIl9fX2JvdHRvbVwiK2QudG9vbG5hbWUucmVwbGFjZSgvW1xcLiAoKS8tXS9nLCBcIl9cIik7fSlcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJlcnJvci1jYXBcIilcbiAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCkgLSA0O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geVNjYWxlKGQueSAtIGQuZV95KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHhTY2FsZShkLngpICsgNDtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLnkgLSBkLmVfeSk7XG4gICAgICB9KTtcblxuICAvLyBhZGQgcmlnaHQgZXJyb3IgY2FwXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgIC5kYXRhKGRhdGEpLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwiZXJyb3ItY2FwXCIpXG4gICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkaXZpZCtcIl9fX3JpZ2h0XCIrZC50b29sbmFtZS5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKTt9KVxuICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB4U2NhbGUoZC54ICsgZC5lX3gpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geVNjYWxlKGQueSkgLSA0O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCArIGQuZV94KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLnkpICsgNDtcbiAgICAgIH0pO1xuXG4gICAgLy8gYWRkIGxlZnQgZXJyb3IgY2FwXG4gICAgc3ZnLmFwcGVuZChcImdcIikuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgLmRhdGEoZGF0YSkuZW50ZXIoKVxuICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJlcnJvci1jYXBcIilcbiAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fbGVmdFwiK2QudG9vbG5hbWUucmVwbGFjZSgvW1xcLiAoKS8tXS9nLCBcIl9cIik7fSlcbiAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4geFNjYWxlKGQueCAtIGQuZV94KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLnkpIC0gNDtcbiAgICAgIH0pXG4gICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHhTY2FsZShkLnggLSBkLmVfeCk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB5U2NhbGUoZC55KSArIDQ7XG4gICAgICB9KTtcblxuICAvLyBhZGQgZG90c1xuICBsZXQgc3ltYm9sID0gZDMuc3ltYm9sKCk7XG5cbiAgbGV0IGZvcm1hdENvbW1hID0gZDMuZm9ybWF0KFwiLFwiKTtcbiAgbGV0IGZvcm1hdERlY2ltYWwgPSBkMy5mb3JtYXQoXCIuNGZcIik7XG5cbiAgbGV0IGRvdHMgPXN2Zy5zZWxlY3RBbGwoXCIuZG90c1wiKVxuICAgIC5kYXRhKGRhdGEpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiZW5jaG1hcmtfcGF0aFwiKTtcbiAgXG4gIC8vIGRlZmluZSB0aGUgc2hhcGVzIG9mIHRoZSBkb3RzXG4gIHZhciBzeW1ib2xHZW5lcmF0b3IgPSBkMy5zeW1ib2woKVxuICAuc2l6ZSgxMDApO1xuXG4gIHZhciBzaGFwZVNjYWxlID0gZDMuc2NhbGVPcmRpbmFsKClcbiAgICAgICAgICAgIC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLnRvb2xuYW1lKSlcbiAgICAgICAgICAgIC5yYW5nZShBcnJheShNYXRoLmNlaWwoZGF0YS5sZW5ndGgvNykpLmZpbGwoW2QzLnN5bWJvbENpcmNsZSwgZDMuc3ltYm9sQ3Jvc3MsIGQzLnN5bWJvbERpYW1vbmQsIGQzLnN5bWJvbFNxdWFyZSwgZDMuc3ltYm9sU3RhciwgZDMuc3ltYm9sVHJpYW5nbGUsIGQzLnN5bWJvbFd5ZV0pLmZsYXQoKSk7XG5cbiAgICBkb3RzLmF0dHIoXCJkXCIsIHN5bWJvbC50eXBlKGZ1bmN0aW9uKGQpe3JldHVybiBzaGFwZVNjYWxlKGQudG9vbG5hbWUpfSkuc2l6ZSgxMjApKVxuICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyAgcmV0dXJuIGRpdmlkK1wiX19fXCIrZC50b29sbmFtZS5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKTt9KVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwibGluZVwiKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsZnVuY3Rpb24oZCl7IHJldHVybiBcInRyYW5zbGF0ZShcIit4U2NhbGUoZC54KStcIixcIit5U2NhbGUoZC55KStcIilcIjsgfSlcbiAgICAgIC5hdHRyKFwiclwiLCA2KVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBjb2xvcihjVmFsdWUoZCkpO1xuICAgICAgfSlcbiAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIC8vIHNob3cgdG9vbHRpcCBvbmx5IGlmIHRoZSB0b29sIGlzIHZpc2libGVcbiAgICAgICAgbGV0IElEID0gZGl2aWQrXCJfX19cIitkLnRvb2xuYW1lLnJlcGxhY2UoL1tcXC4gKCkvLV0vZywgXCJfXCIpO1xuICAgICAgICBpZiAobWV0cmljX3guc3RhcnRzV2l0aChcIk9FQk1cIikgPT0gdHJ1ZSl7XG4gICAgICAgICAgdmFyIHR4dF94ID0gbWV0cmljc19uYW1lc1ttZXRyaWNfeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR4dF94ID0gbWV0cmljX3g7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRyaWNfeS5zdGFydHNXaXRoKFwiT0VCTVwiKSA9PSB0cnVlKXtcbiAgICAgICAgICB2YXIgdHh0X3kgPSBtZXRyaWNzX25hbWVzW21ldHJpY195XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHh0X3kgPSBtZXRyaWNfeTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGQzLnNlbGVjdChcIiNcIitJRCkuc3R5bGUoXCJvcGFjaXR5XCIpID09IDEpIHtcbiAgICAgICAgICBkaXYudHJhbnNpdGlvbigpXHRcdFxuICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKVx0XHRcbiAgICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLFwiYmxvY2tcIilcdFx0XG4gICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1x0XHRcbiAgICAgICAgICBkaXYuaHRtbChcIjxiPlwiICsgZC50b29sbmFtZSArIFwiPC9iPjxici8+XCIgICsgdHh0X3ggKyBcIjogXCIgKyBmb3JtYXRDb21tYShkLngpICsgXCI8YnIvPlwiICArIHR4dF95ICsgXCI6IFwiICsgZm9ybWF0RGVjaW1hbChkLnkpKVx0XG4gICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYKSArIFwicHhcIilcdFx0XG4gICAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkpICsgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgfSlcdFx0XHRcdFx0XG4gICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XHRcdFxuICAgICAgICBkaXYudHJhbnNpdGlvbigpXHRcdFxuICAgICAgICAgIC5kdXJhdGlvbigxNTAwKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIixcIm5vbmVcIilcdFx0XG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcdFxuICAgICAgfSk7XG4gICAgXG4gICAgXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart_coordinates.js\n");

/***/ }),

/***/ "./src/classification.js":
/*!*******************************!*\
  !*** ./src/classification.js ***!
  \*******************************/
/*! exports provided: compute_classification */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compute_classification\", function() { return compute_classification; });\n/* harmony import */ var _remove_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove_tools */ \"./src/remove_tools.js\");\n/* harmony import */ var pareto_frontier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pareto-frontier */ \"./node_modules/pareto-frontier/index.js\");\n/* harmony import */ var pareto_frontier__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pareto_frontier__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _squares__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squares */ \"./src/squares.js\");\n/* harmony import */ var _diagonals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./diagonals */ \"./src/diagonals.js\");\n/* harmony import */ var _clusters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clusters */ \"./src/clusters.js\");\n\n\n\n\n\n\nfunction compute_classification(data, svg, xScale, yScale, div, width, height, removed_tools,divid, classification_type, legend_color_palette, better) {\n\n  let transform_to_table; //this variable is set to true if there are table elements with the corresponden divid in the html file\n  // every time a new classification is compute the previous results table is deleted (if it exists)\n  if (document.getElementById(divid + \"_table\") != null) {\n    document.getElementById(divid + \"_table\").innerHTML = '';\n    transform_to_table = true;\n  };\n\n  // append optimization arrow\n  add_arrow(divid, svg, xScale, yScale, better);\n\n  if (classification_type == ( divid + \"__squares\")) {\n    draw_pareto(data, svg, xScale, yScale, removed_tools,divid, better);\n    Object(_squares__WEBPACK_IMPORTED_MODULE_2__[\"get_square_quartiles\"])(data, svg, xScale, yScale, div, removed_tools,better,divid, transform_to_table, legend_color_palette);\n    Object(_squares__WEBPACK_IMPORTED_MODULE_2__[\"append_quartile_numbers_to_plot\"]) (svg, xScale, yScale, better,divid);\n  }  \n  else if (classification_type == (divid + \"__diagonals\")) {\n    draw_pareto(data, svg, xScale, yScale, removed_tools,divid, better);\n    Object(_diagonals__WEBPACK_IMPORTED_MODULE_3__[\"get_diagonal_quartiles\"])(data, svg, xScale, yScale, div, width, height, removed_tools, better,divid, transform_to_table, legend_color_palette);\n  } \n  else if (classification_type == (divid + \"__clusters\")) {\n    draw_pareto(data, svg, xScale, yScale, removed_tools,divid, better);\n    Object(_clusters__WEBPACK_IMPORTED_MODULE_4__[\"get_clusters\"])(data, svg, xScale, yScale, div, width, height, removed_tools, better,divid, transform_to_table, legend_color_palette);\n  } else {\n    draw_pareto(data, svg, xScale, yScale, removed_tools,divid, better);\n  }\n  \n};\n\nfunction add_arrow(divid, svg, xScale, yScale, better){\n\n  // append optimization arrow\n  \n  svg.append(\"svg:defs\").append(\"svg:marker\")\n  .attr(\"id\", \"opt_triangle\")\n  .attr(\"class\", function (d) { return divid+\"___better_annotation\";})\n  .attr(\"refX\", 6)\n  .attr(\"refY\", 6)\n  .attr(\"markerWidth\", 30)\n  .attr(\"markerHeight\", 30)\n  .attr(\"markerUnits\",\"userSpaceOnUse\")\n  .attr(\"orient\", \"auto\")\n  .append(\"path\")\n  .attr(\"d\", \"M 0 0 12 6 0 12 3 6\")\n  .style(\"fill\", \"black\")\n  .style(\"opacity\", 0.7);\n\n  let x_axis = xScale.domain();\n  let y_axis = yScale.domain();\n\n  // set coordinates depending on optimization\n  let x1, y1, x2, y2, top;\n  if (better == \"bottom-right\"){\n    x1 = (x_axis[1]-(0.05*(x_axis[1]-x_axis[0])))\n    y1 = (y_axis[1]-(0.9*(y_axis[1]-y_axis[0])))\n    x2 = (x_axis[1]-(0.009*(x_axis[1]-x_axis[0]))) \n    y2 = (y_axis[1]-(0.97*(y_axis[1]-y_axis[0]))) \n    top = 0\n } \n else if (better == \"top-right\"){\n    x1 = (x_axis[1]-(0.05*(x_axis[1]-x_axis[0])))\n    y1 = (y_axis[1]-(0.1*(y_axis[1]-y_axis[0])))\n    x2 = (x_axis[1]-(0.009*(x_axis[1]-x_axis[0]))) \n    y2 = (y_axis[1]-(0.03*(y_axis[1]-y_axis[0]))) \n    top = 1\n };\n\n  var line = svg.append(\"line\")\n  .attr(\"class\", function (d) { return divid+\"___better_annotation\";})\n  .attr(\"x1\",xScale(x1))\n  .attr(\"y1\",yScale(y1))\n  .attr(\"x2\",xScale(x2)) \n  .attr(\"y2\",yScale(y2))\n  .attr(\"stroke\",\"black\")  \n  .attr(\"stroke-width\",2)  \n  .attr(\"marker-end\",\"url(#opt_triangle)\")\n  .style(\"opacity\", 0.4);  \n\n  svg.append(\"text\")\n  .attr(\"class\", function (d) { return divid+\"___better_annotation\";})\n  .attr(\"x\", xScale(x_axis[1]))\n  .attr(\"y\", yScale(y_axis[top]))\n  .style(\"opacity\", 0.4)\n  .style(\"font-size\", \".7vw\")\n  .text(\"better\");\n\n};\n\nfunction draw_pareto(data, svg, xScale, yScale, removed_tools,divid, better){\n\n  const points = [];\n\n  let tools_not_hidden = Object(_remove_tools__WEBPACK_IMPORTED_MODULE_0__[\"remove_hidden_tools\"])(data, removed_tools);\n\n  tools_not_hidden.forEach(function(element) {\n    points.push([element['x'], element['y']])\n  });\n\n  let pf_coords;\n  let x_axis = xScale.domain();\n  let y_axis = yScale.domain();\n\n  if (better == \"bottom-right\"){\n    pf_coords = pareto_frontier__WEBPACK_IMPORTED_MODULE_1__[\"getParetoFrontier\"](points, { optimize: 'bottomRight'});\n    // append edges to pareto frontier\n    pf_coords.unshift ([pf_coords[0][0], y_axis[1]]);\n    pf_coords.push([x_axis[0], pf_coords[pf_coords.length -1 ][1]]);\n  } else if (better == \"top-right\"){\n    pf_coords = pareto_frontier__WEBPACK_IMPORTED_MODULE_1__[\"getParetoFrontier\"](points, { optimize: 'topRight'});\n    // append edges to pareto frontier\n    pf_coords.unshift ([pf_coords[0][0], y_axis[0]]);\n    pf_coords.push([x_axis[0], pf_coords[pf_coords.length -1 ][1]]);\n\n  }\n  \n  for (var i = 0; i < (pf_coords.length-1); i++) {\n    svg.append(\"line\")\n       .attr(\"clip-path\",\"url(#clip)\")\n       .attr(\"x1\", xScale(pf_coords[i][0]))\n       .attr(\"y1\", yScale(pf_coords[i][1]))\n       .attr(\"x2\", xScale(pf_coords[i+1][0]))\n       .attr(\"y2\", yScale(pf_coords[i+1][1]))  \n       .attr(\"id\", function (d) { return divid+\"___pareto\";})\n       .attr(\"stroke\", \"grey\")\n       .attr(\"stroke-width\",2)\n       .style(\"stroke-dasharray\", (\"20, 5\"))\n       .style(\"opacity\", 0.4)\n  };\n\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2xhc3NpZmljYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3NpZmljYXRpb24uanM/NTlkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW1vdmVfaGlkZGVuX3Rvb2xzfSBmcm9tIFwiLi9yZW1vdmVfdG9vbHNcIjtcbmltcG9ydCAqIGFzIHBmIGZyb20gJ3BhcmV0by1mcm9udGllcic7XG5pbXBvcnQgeyBnZXRfc3F1YXJlX3F1YXJ0aWxlcywgYXBwZW5kX3F1YXJ0aWxlX251bWJlcnNfdG9fcGxvdCB9IGZyb20gXCIuL3NxdWFyZXNcIjtcbmltcG9ydCB7IGdldF9kaWFnb25hbF9xdWFydGlsZXMgfSBmcm9tIFwiLi9kaWFnb25hbHNcIjtcbmltcG9ydCB7IGdldF9jbHVzdGVycyB9IGZyb20gXCIuL2NsdXN0ZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX2NsYXNzaWZpY2F0aW9uKGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgd2lkdGgsIGhlaWdodCwgcmVtb3ZlZF90b29scyxkaXZpZCwgY2xhc3NpZmljYXRpb25fdHlwZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIGJldHRlcikge1xuXG4gIGxldCB0cmFuc2Zvcm1fdG9fdGFibGU7IC8vdGhpcyB2YXJpYWJsZSBpcyBzZXQgdG8gdHJ1ZSBpZiB0aGVyZSBhcmUgdGFibGUgZWxlbWVudHMgd2l0aCB0aGUgY29ycmVzcG9uZGVuIGRpdmlkIGluIHRoZSBodG1sIGZpbGVcbiAgLy8gZXZlcnkgdGltZSBhIG5ldyBjbGFzc2lmaWNhdGlvbiBpcyBjb21wdXRlIHRoZSBwcmV2aW91cyByZXN1bHRzIHRhYmxlIGlzIGRlbGV0ZWQgKGlmIGl0IGV4aXN0cylcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkICsgXCJfdGFibGVcIikgIT0gbnVsbCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkICsgXCJfdGFibGVcIikuaW5uZXJIVE1MID0gJyc7XG4gICAgdHJhbnNmb3JtX3RvX3RhYmxlID0gdHJ1ZTtcbiAgfTtcblxuICAvLyBhcHBlbmQgb3B0aW1pemF0aW9uIGFycm93XG4gIGFkZF9hcnJvdyhkaXZpZCwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgYmV0dGVyKTtcblxuICBpZiAoY2xhc3NpZmljYXRpb25fdHlwZSA9PSAoIGRpdmlkICsgXCJfX3NxdWFyZXNcIikpIHtcbiAgICBkcmF3X3BhcmV0byhkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCByZW1vdmVkX3Rvb2xzLGRpdmlkLCBiZXR0ZXIpO1xuICAgIGdldF9zcXVhcmVfcXVhcnRpbGVzKGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgcmVtb3ZlZF90b29scyxiZXR0ZXIsZGl2aWQsIHRyYW5zZm9ybV90b190YWJsZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpO1xuICAgIGFwcGVuZF9xdWFydGlsZV9udW1iZXJzX3RvX3Bsb3QgKHN2ZywgeFNjYWxlLCB5U2NhbGUsIGJldHRlcixkaXZpZCk7XG4gIH0gIFxuICBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbl90eXBlID09IChkaXZpZCArIFwiX19kaWFnb25hbHNcIikpIHtcbiAgICBkcmF3X3BhcmV0byhkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCByZW1vdmVkX3Rvb2xzLGRpdmlkLCBiZXR0ZXIpO1xuICAgIGdldF9kaWFnb25hbF9xdWFydGlsZXMoZGF0YSwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgZGl2LCB3aWR0aCwgaGVpZ2h0LCByZW1vdmVkX3Rvb2xzLCBiZXR0ZXIsZGl2aWQsIHRyYW5zZm9ybV90b190YWJsZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpO1xuICB9IFxuICBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbl90eXBlID09IChkaXZpZCArIFwiX19jbHVzdGVyc1wiKSkge1xuICAgIGRyYXdfcGFyZXRvKGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIHJlbW92ZWRfdG9vbHMsZGl2aWQsIGJldHRlcik7XG4gICAgZ2V0X2NsdXN0ZXJzKGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgd2lkdGgsIGhlaWdodCwgcmVtb3ZlZF90b29scywgYmV0dGVyLGRpdmlkLCB0cmFuc2Zvcm1fdG9fdGFibGUsIGxlZ2VuZF9jb2xvcl9wYWxldHRlKTtcbiAgfSBlbHNlIHtcbiAgICBkcmF3X3BhcmV0byhkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCByZW1vdmVkX3Rvb2xzLGRpdmlkLCBiZXR0ZXIpO1xuICB9XG4gIFxufTtcblxuZnVuY3Rpb24gYWRkX2Fycm93KGRpdmlkLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBiZXR0ZXIpe1xuXG4gIC8vIGFwcGVuZCBvcHRpbWl6YXRpb24gYXJyb3dcbiAgXG4gIHN2Zy5hcHBlbmQoXCJzdmc6ZGVmc1wiKS5hcHBlbmQoXCJzdmc6bWFya2VyXCIpXG4gIC5hdHRyKFwiaWRcIiwgXCJvcHRfdHJpYW5nbGVcIilcbiAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19iZXR0ZXJfYW5ub3RhdGlvblwiO30pXG4gIC5hdHRyKFwicmVmWFwiLCA2KVxuICAuYXR0cihcInJlZllcIiwgNilcbiAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAzMClcbiAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMzApXG4gIC5hdHRyKFwibWFya2VyVW5pdHNcIixcInVzZXJTcGFjZU9uVXNlXCIpXG4gIC5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKVxuICAuYXBwZW5kKFwicGF0aFwiKVxuICAuYXR0cihcImRcIiwgXCJNIDAgMCAxMiA2IDAgMTIgMyA2XCIpXG4gIC5zdHlsZShcImZpbGxcIiwgXCJibGFja1wiKVxuICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNyk7XG5cbiAgbGV0IHhfYXhpcyA9IHhTY2FsZS5kb21haW4oKTtcbiAgbGV0IHlfYXhpcyA9IHlTY2FsZS5kb21haW4oKTtcblxuICAvLyBzZXQgY29vcmRpbmF0ZXMgZGVwZW5kaW5nIG9uIG9wdGltaXphdGlvblxuICBsZXQgeDEsIHkxLCB4MiwgeTIsIHRvcDtcbiAgaWYgKGJldHRlciA9PSBcImJvdHRvbS1yaWdodFwiKXtcbiAgICB4MSA9ICh4X2F4aXNbMV0tKDAuMDUqKHhfYXhpc1sxXS14X2F4aXNbMF0pKSlcbiAgICB5MSA9ICh5X2F4aXNbMV0tKDAuOSooeV9heGlzWzFdLXlfYXhpc1swXSkpKVxuICAgIHgyID0gKHhfYXhpc1sxXS0oMC4wMDkqKHhfYXhpc1sxXS14X2F4aXNbMF0pKSkgXG4gICAgeTIgPSAoeV9heGlzWzFdLSgwLjk3Kih5X2F4aXNbMV0teV9heGlzWzBdKSkpIFxuICAgIHRvcCA9IDBcbiB9IFxuIGVsc2UgaWYgKGJldHRlciA9PSBcInRvcC1yaWdodFwiKXtcbiAgICB4MSA9ICh4X2F4aXNbMV0tKDAuMDUqKHhfYXhpc1sxXS14X2F4aXNbMF0pKSlcbiAgICB5MSA9ICh5X2F4aXNbMV0tKDAuMSooeV9heGlzWzFdLXlfYXhpc1swXSkpKVxuICAgIHgyID0gKHhfYXhpc1sxXS0oMC4wMDkqKHhfYXhpc1sxXS14X2F4aXNbMF0pKSkgXG4gICAgeTIgPSAoeV9heGlzWzFdLSgwLjAzKih5X2F4aXNbMV0teV9heGlzWzBdKSkpIFxuICAgIHRvcCA9IDFcbiB9O1xuXG4gIHZhciBsaW5lID0gc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19iZXR0ZXJfYW5ub3RhdGlvblwiO30pXG4gIC5hdHRyKFwieDFcIix4U2NhbGUoeDEpKVxuICAuYXR0cihcInkxXCIseVNjYWxlKHkxKSlcbiAgLmF0dHIoXCJ4MlwiLHhTY2FsZSh4MikpIFxuICAuYXR0cihcInkyXCIseVNjYWxlKHkyKSlcbiAgLmF0dHIoXCJzdHJva2VcIixcImJsYWNrXCIpICBcbiAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwyKSAgXG4gIC5hdHRyKFwibWFya2VyLWVuZFwiLFwidXJsKCNvcHRfdHJpYW5nbGUpXCIpXG4gIC5zdHlsZShcIm9wYWNpdHlcIiwgMC40KTsgIFxuXG4gIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fYmV0dGVyX2Fubm90YXRpb25cIjt9KVxuICAuYXR0cihcInhcIiwgeFNjYWxlKHhfYXhpc1sxXSkpXG4gIC5hdHRyKFwieVwiLCB5U2NhbGUoeV9heGlzW3RvcF0pKVxuICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiLjd2d1wiKVxuICAudGV4dChcImJldHRlclwiKTtcblxufTtcblxuZnVuY3Rpb24gZHJhd19wYXJldG8oZGF0YSwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgcmVtb3ZlZF90b29scyxkaXZpZCwgYmV0dGVyKXtcblxuICBjb25zdCBwb2ludHMgPSBbXTtcblxuICBsZXQgdG9vbHNfbm90X2hpZGRlbiA9IHJlbW92ZV9oaWRkZW5fdG9vbHMoZGF0YSwgcmVtb3ZlZF90b29scyk7XG5cbiAgdG9vbHNfbm90X2hpZGRlbi5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBwb2ludHMucHVzaChbZWxlbWVudFsneCddLCBlbGVtZW50Wyd5J11dKVxuICB9KTtcblxuICBsZXQgcGZfY29vcmRzO1xuICBsZXQgeF9heGlzID0geFNjYWxlLmRvbWFpbigpO1xuICBsZXQgeV9heGlzID0geVNjYWxlLmRvbWFpbigpO1xuXG4gIGlmIChiZXR0ZXIgPT0gXCJib3R0b20tcmlnaHRcIil7XG4gICAgcGZfY29vcmRzID0gcGYuZ2V0UGFyZXRvRnJvbnRpZXIocG9pbnRzLCB7IG9wdGltaXplOiAnYm90dG9tUmlnaHQnfSk7XG4gICAgLy8gYXBwZW5kIGVkZ2VzIHRvIHBhcmV0byBmcm9udGllclxuICAgIHBmX2Nvb3Jkcy51bnNoaWZ0IChbcGZfY29vcmRzWzBdWzBdLCB5X2F4aXNbMV1dKTtcbiAgICBwZl9jb29yZHMucHVzaChbeF9heGlzWzBdLCBwZl9jb29yZHNbcGZfY29vcmRzLmxlbmd0aCAtMSBdWzFdXSk7XG4gIH0gZWxzZSBpZiAoYmV0dGVyID09IFwidG9wLXJpZ2h0XCIpe1xuICAgIHBmX2Nvb3JkcyA9IHBmLmdldFBhcmV0b0Zyb250aWVyKHBvaW50cywgeyBvcHRpbWl6ZTogJ3RvcFJpZ2h0J30pO1xuICAgIC8vIGFwcGVuZCBlZGdlcyB0byBwYXJldG8gZnJvbnRpZXJcbiAgICBwZl9jb29yZHMudW5zaGlmdCAoW3BmX2Nvb3Jkc1swXVswXSwgeV9heGlzWzBdXSk7XG4gICAgcGZfY29vcmRzLnB1c2goW3hfYXhpc1swXSwgcGZfY29vcmRzW3BmX2Nvb3Jkcy5sZW5ndGggLTEgXVsxXV0pO1xuXG4gIH1cbiAgXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgKHBmX2Nvb3Jkcy5sZW5ndGgtMSk7IGkrKykge1xuICAgIHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgLmF0dHIoXCJjbGlwLXBhdGhcIixcInVybCgjY2xpcClcIilcbiAgICAgICAuYXR0cihcIngxXCIsIHhTY2FsZShwZl9jb29yZHNbaV1bMF0pKVxuICAgICAgIC5hdHRyKFwieTFcIiwgeVNjYWxlKHBmX2Nvb3Jkc1tpXVsxXSkpXG4gICAgICAgLmF0dHIoXCJ4MlwiLCB4U2NhbGUocGZfY29vcmRzW2krMV1bMF0pKVxuICAgICAgIC5hdHRyKFwieTJcIiwgeVNjYWxlKHBmX2Nvb3Jkc1tpKzFdWzFdKSkgIFxuICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fcGFyZXRvXCI7fSlcbiAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImdyZXlcIilcbiAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLDIpXG4gICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCAoXCIyMCwgNVwiKSlcbiAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgfTtcblxuXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/classification.js\n");

/***/ }),

/***/ "./src/clusters.js":
/*!*************************!*\
  !*** ./src/clusters.js ***!
  \*************************/
/*! exports provided: get_clusters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_clusters\", function() { return get_clusters; });\n/* harmony import */ var clusters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clusters */ \"./node_modules/clusters/clusters.js\");\n/* harmony import */ var clusters__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clusters__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var d3_polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-polygon */ \"./node_modules/d3-polygon/src/index.js\");\n/* harmony import */ var _remove_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./remove_tools */ \"./src/remove_tools.js\");\n/* harmony import */ var _table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./table */ \"./src/table.js\");\n\n\n\n\n\nfunction get_clusters(data, svg, xScale, yScale, div, width, height, removed_tools, better,divid, transform_to_table, legend_color_palette) {\n\n  let tools_not_hidden = Object(_remove_tools__WEBPACK_IMPORTED_MODULE_2__[\"remove_hidden_tools\"])(data, removed_tools);\n  let x_values = tools_not_hidden.map(a => a.x);\n  let y_values = tools_not_hidden.map(a => a.y);\n\n  let coordinates = [];\n\n  for (let i = 0; i < x_values.length; i++) {\n    coordinates.push([x_values[i], y_values[i]]);\n  };\n  \n  //number of clusters\n  clusters__WEBPACK_IMPORTED_MODULE_0__[\"k\"](4);\n\n  //number of iterations (higher number gives more time to converge)\n  clusters__WEBPACK_IMPORTED_MODULE_0__[\"iterations\"](500);\n\n  //data from which to identify clusters\n  clusters__WEBPACK_IMPORTED_MODULE_0__[\"data\"](coordinates);\n\n  let results = clusters__WEBPACK_IMPORTED_MODULE_0__[\"clusters\"]();\n\n  // normalize data to 0-1 range\n  let centroids_x = []\n  let centroids_y = []\n  results.forEach(function(element) {\n      centroids_x.push(element.centroid[0])\n      centroids_y.push(element.centroid[1])\n  });\n  let [x_norm, y_norm] = normalize_data(centroids_x, centroids_y)\n\n  // get distance from centroids to better corner\n\n  let scores = [];\n  if (better == \"top-right\") {\n\n    for (let i = 0; i < x_norm.length; i++) {\n      let distance = x_norm[i] + y_norm[i];\n      scores.push(distance);\n      results[i]['score'] = distance;\n    };\n\n  } else if (better == \"bottom-right\"){\n    \n    for (let i = 0; i < x_norm.length; i++) {\n      let distance = x_norm[i] + (1 - y_norm[i]);\n      scores.push(distance);\n      results[i]['score'] = distance;\n    };\n  };\n\n  let sorted_results = sortByKey(results, \"score\");\n\n  sorted_results = print_clusters(svg, divid, xScale, yScale, sorted_results);\n    \n  //the tranformation to tabular format is done only if there are any table elements in the html file\n  if (transform_to_table == true) {\n    transform_clust_classif_to_table(tools_not_hidden, sorted_results, divid, legend_color_palette, data, removed_tools);\n  };\n\n};\n\n\nfunction print_clusters(svg, divid, xScale, yScale, sorted_results){\n\n  let cluster_no = 1;\n\n  var arrayOfPolygons =  [];\n\n  sorted_results.forEach(function(element) {\n\n    var poly = [];\n\n    element['cluster'] = cluster_no;\n    svg.append(\"text\")\n      .attr(\"class\", function (d) { return divid+\"___cluster_num\";})\n      .attr(\"x\", xScale(element.centroid[0]))\n      .attr(\"y\", yScale(element.centroid[1]))\n      .style(\"opacity\", 0.9)\n      .style(\"font-size\", \"2vw\")\n      .style(\"fill\", \"#0A58A2\")\n      .text(cluster_no);\n    let participants = element['points'];\n    participants.forEach(function(coords) {\n\n      poly.push([coords[0], coords[1]])\n      svg.append(\"line\")\n       .attr(\"x1\", xScale(element.centroid[0]))\n       .attr(\"y1\", yScale(element.centroid[1]))\n       .attr(\"x2\", xScale(coords[0]))\n       .attr(\"y2\", yScale(coords[1]))  \n       .attr(\"class\", function (d) { return divid+\"___clust_lines\";})\n       .attr(\"stroke\", \"#0A58A2\")\n       .attr(\"stroke-width\",2)\n       .style(\"stroke-dasharray\", (\"20, 5\"))\n       .style(\"opacity\", 0.4)\n    });\n\n    var hull = d3_polygon__WEBPACK_IMPORTED_MODULE_1__[\"polygonHull\"](poly);\n\n    arrayOfPolygons.push({\"points\": hull});\n\n    cluster_no++;\n  });\n\n  svg.selectAll(\"polygon\")\n  .data(arrayOfPolygons)\n  .enter().append(\"polygon\")\n  .attr(\"points\",function(d) { \n    if (d.points != null){\n      return d.points.map(function(d) { \n        return [xScale(d[0]),yScale(d[1])].join(\",\");\n      }).join(\" \");\n    };\n  })\n  .attr(\"class\", function (d) { return divid+\"___clust_polygons\";})\n  .attr(\"fill\", \"#0A58A2\")\n  .style(\"opacity\", 0.1);\n\n    \n\n  return (sorted_results);\n};\n\n\nfunction transform_clust_classif_to_table(data, results, divid, legend_color_palette, all_participants, removed_tools){\n\n  data.forEach(function(element) {\n\n    let coords = [element.x, element.y];\n\n    results.forEach(function(result) {\n      \n      if (isArrayInArray(result.points, coords) == true){\n        element['quartile'] = result.cluster;\n      };\n\n    });\n  });\n\n  Object(_table__WEBPACK_IMPORTED_MODULE_3__[\"fill_in_table\"]) (divid, data, all_participants, removed_tools);\n  Object(_table__WEBPACK_IMPORTED_MODULE_3__[\"set_cell_colors\"])(divid, legend_color_palette, removed_tools);\n\n};\n\nfunction normalize_data(x_values, y_values){\n\n    let maxX = Math.max.apply(null, x_values);\n    let maxY = Math.max.apply(null, y_values);\n    \n    let x_norm = x_values.map(function(e) {  \n      return e / maxX;\n    });\n  \n    let y_norm = y_values.map(function(e) {  \n      return e / maxY;\n    });\n  \n    return [x_norm, y_norm];\n  };\n  \nfunction sortByKey(array, key) {\n    return array.sort(function(a, b) {\n        var x = a[key]; var y = b[key];\n        return ((x < y) ? -1 : ((x > y) ? 1 : 0)) * -1;\n    });\n  };\n  \n  function isArrayInArray(arr, item){\n    var item_as_string = JSON.stringify(item);\n  \n    var contains = arr.some(function(ele){\n      return JSON.stringify(ele) === item_as_string;\n    });\n    return contains;\n  };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2x1c3RlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2x1c3RlcnMuanM/MDZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiAgYXMgY2x1c3Rlck1ha2VyIGZyb20gJ2NsdXN0ZXJzJztcbmltcG9ydCAqIGFzIGQzUG9seWdvbiBmcm9tIFwiZDMtcG9seWdvblwiO1xuaW1wb3J0IHsgcmVtb3ZlX2hpZGRlbl90b29sc30gZnJvbSBcIi4vcmVtb3ZlX3Rvb2xzXCI7XG5pbXBvcnQgeyBmaWxsX2luX3RhYmxlLCBzZXRfY2VsbF9jb2xvcnMgfSBmcm9tIFwiLi90YWJsZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY2x1c3RlcnMoZGF0YSwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgZGl2LCB3aWR0aCwgaGVpZ2h0LCByZW1vdmVkX3Rvb2xzLCBiZXR0ZXIsZGl2aWQsIHRyYW5zZm9ybV90b190YWJsZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpIHtcblxuICBsZXQgdG9vbHNfbm90X2hpZGRlbiA9IHJlbW92ZV9oaWRkZW5fdG9vbHMoZGF0YSwgcmVtb3ZlZF90b29scyk7XG4gIGxldCB4X3ZhbHVlcyA9IHRvb2xzX25vdF9oaWRkZW4ubWFwKGEgPT4gYS54KTtcbiAgbGV0IHlfdmFsdWVzID0gdG9vbHNfbm90X2hpZGRlbi5tYXAoYSA9PiBhLnkpO1xuXG4gIGxldCBjb29yZGluYXRlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeF92YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb29yZGluYXRlcy5wdXNoKFt4X3ZhbHVlc1tpXSwgeV92YWx1ZXNbaV1dKTtcbiAgfTtcbiAgXG4gIC8vbnVtYmVyIG9mIGNsdXN0ZXJzXG4gIGNsdXN0ZXJNYWtlci5rKDQpO1xuXG4gIC8vbnVtYmVyIG9mIGl0ZXJhdGlvbnMgKGhpZ2hlciBudW1iZXIgZ2l2ZXMgbW9yZSB0aW1lIHRvIGNvbnZlcmdlKVxuICBjbHVzdGVyTWFrZXIuaXRlcmF0aW9ucyg1MDApO1xuXG4gIC8vZGF0YSBmcm9tIHdoaWNoIHRvIGlkZW50aWZ5IGNsdXN0ZXJzXG4gIGNsdXN0ZXJNYWtlci5kYXRhKGNvb3JkaW5hdGVzKTtcblxuICBsZXQgcmVzdWx0cyA9IGNsdXN0ZXJNYWtlci5jbHVzdGVycygpO1xuXG4gIC8vIG5vcm1hbGl6ZSBkYXRhIHRvIDAtMSByYW5nZVxuICBsZXQgY2VudHJvaWRzX3ggPSBbXVxuICBsZXQgY2VudHJvaWRzX3kgPSBbXVxuICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgY2VudHJvaWRzX3gucHVzaChlbGVtZW50LmNlbnRyb2lkWzBdKVxuICAgICAgY2VudHJvaWRzX3kucHVzaChlbGVtZW50LmNlbnRyb2lkWzFdKVxuICB9KTtcbiAgbGV0IFt4X25vcm0sIHlfbm9ybV0gPSBub3JtYWxpemVfZGF0YShjZW50cm9pZHNfeCwgY2VudHJvaWRzX3kpXG5cbiAgLy8gZ2V0IGRpc3RhbmNlIGZyb20gY2VudHJvaWRzIHRvIGJldHRlciBjb3JuZXJcblxuICBsZXQgc2NvcmVzID0gW107XG4gIGlmIChiZXR0ZXIgPT0gXCJ0b3AtcmlnaHRcIikge1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4X25vcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBkaXN0YW5jZSA9IHhfbm9ybVtpXSArIHlfbm9ybVtpXTtcbiAgICAgIHNjb3Jlcy5wdXNoKGRpc3RhbmNlKTtcbiAgICAgIHJlc3VsdHNbaV1bJ3Njb3JlJ10gPSBkaXN0YW5jZTtcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiAoYmV0dGVyID09IFwiYm90dG9tLXJpZ2h0XCIpe1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeF9ub3JtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZGlzdGFuY2UgPSB4X25vcm1baV0gKyAoMSAtIHlfbm9ybVtpXSk7XG4gICAgICBzY29yZXMucHVzaChkaXN0YW5jZSk7XG4gICAgICByZXN1bHRzW2ldWydzY29yZSddID0gZGlzdGFuY2U7XG4gICAgfTtcbiAgfTtcblxuICBsZXQgc29ydGVkX3Jlc3VsdHMgPSBzb3J0QnlLZXkocmVzdWx0cywgXCJzY29yZVwiKTtcblxuICBzb3J0ZWRfcmVzdWx0cyA9IHByaW50X2NsdXN0ZXJzKHN2ZywgZGl2aWQsIHhTY2FsZSwgeVNjYWxlLCBzb3J0ZWRfcmVzdWx0cyk7XG4gICAgXG4gIC8vdGhlIHRyYW5mb3JtYXRpb24gdG8gdGFidWxhciBmb3JtYXQgaXMgZG9uZSBvbmx5IGlmIHRoZXJlIGFyZSBhbnkgdGFibGUgZWxlbWVudHMgaW4gdGhlIGh0bWwgZmlsZVxuICBpZiAodHJhbnNmb3JtX3RvX3RhYmxlID09IHRydWUpIHtcbiAgICB0cmFuc2Zvcm1fY2x1c3RfY2xhc3NpZl90b190YWJsZSh0b29sc19ub3RfaGlkZGVuLCBzb3J0ZWRfcmVzdWx0cywgZGl2aWQsIGxlZ2VuZF9jb2xvcl9wYWxldHRlLCBkYXRhLCByZW1vdmVkX3Rvb2xzKTtcbiAgfTtcblxufTtcblxuXG5mdW5jdGlvbiBwcmludF9jbHVzdGVycyhzdmcsIGRpdmlkLCB4U2NhbGUsIHlTY2FsZSwgc29ydGVkX3Jlc3VsdHMpe1xuXG4gIGxldCBjbHVzdGVyX25vID0gMTtcblxuICB2YXIgYXJyYXlPZlBvbHlnb25zID0gIFtdO1xuXG4gIHNvcnRlZF9yZXN1bHRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgdmFyIHBvbHkgPSBbXTtcblxuICAgIGVsZW1lbnRbJ2NsdXN0ZXInXSA9IGNsdXN0ZXJfbm87XG4gICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fY2x1c3Rlcl9udW1cIjt9KVxuICAgICAgLmF0dHIoXCJ4XCIsIHhTY2FsZShlbGVtZW50LmNlbnRyb2lkWzBdKSlcbiAgICAgIC5hdHRyKFwieVwiLCB5U2NhbGUoZWxlbWVudC5jZW50cm9pZFsxXSkpXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuOSlcbiAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjJ2d1wiKVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiMwQTU4QTJcIilcbiAgICAgIC50ZXh0KGNsdXN0ZXJfbm8pO1xuICAgIGxldCBwYXJ0aWNpcGFudHMgPSBlbGVtZW50Wydwb2ludHMnXTtcbiAgICBwYXJ0aWNpcGFudHMuZm9yRWFjaChmdW5jdGlvbihjb29yZHMpIHtcblxuICAgICAgcG9seS5wdXNoKFtjb29yZHNbMF0sIGNvb3Jkc1sxXV0pXG4gICAgICBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgIC5hdHRyKFwieDFcIiwgeFNjYWxlKGVsZW1lbnQuY2VudHJvaWRbMF0pKVxuICAgICAgIC5hdHRyKFwieTFcIiwgeVNjYWxlKGVsZW1lbnQuY2VudHJvaWRbMV0pKVxuICAgICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKGNvb3Jkc1swXSkpXG4gICAgICAgLmF0dHIoXCJ5MlwiLCB5U2NhbGUoY29vcmRzWzFdKSkgIFxuICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fY2x1c3RfbGluZXNcIjt9KVxuICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiIzBBNThBMlwiKVxuICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMilcbiAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIChcIjIwLCA1XCIpKVxuICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC40KVxuICAgIH0pO1xuXG4gICAgdmFyIGh1bGwgPSBkM1BvbHlnb24ucG9seWdvbkh1bGwocG9seSk7XG5cbiAgICBhcnJheU9mUG9seWdvbnMucHVzaCh7XCJwb2ludHNcIjogaHVsbH0pO1xuXG4gICAgY2x1c3Rlcl9ubysrO1xuICB9KTtcblxuICBzdmcuc2VsZWN0QWxsKFwicG9seWdvblwiKVxuICAuZGF0YShhcnJheU9mUG9seWdvbnMpXG4gIC5lbnRlcigpLmFwcGVuZChcInBvbHlnb25cIilcbiAgLmF0dHIoXCJwb2ludHNcIixmdW5jdGlvbihkKSB7IFxuICAgIGlmIChkLnBvaW50cyAhPSBudWxsKXtcbiAgICAgIHJldHVybiBkLnBvaW50cy5tYXAoZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgcmV0dXJuIFt4U2NhbGUoZFswXSkseVNjYWxlKGRbMV0pXS5qb2luKFwiLFwiKTtcbiAgICAgIH0pLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gIH0pXG4gIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fY2x1c3RfcG9seWdvbnNcIjt9KVxuICAuYXR0cihcImZpbGxcIiwgXCIjMEE1OEEyXCIpXG4gIC5zdHlsZShcIm9wYWNpdHlcIiwgMC4xKTtcblxuICAgIFxuXG4gIHJldHVybiAoc29ydGVkX3Jlc3VsdHMpO1xufTtcblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1fY2x1c3RfY2xhc3NpZl90b190YWJsZShkYXRhLCByZXN1bHRzLCBkaXZpZCwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIGFsbF9wYXJ0aWNpcGFudHMsIHJlbW92ZWRfdG9vbHMpe1xuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICBsZXQgY29vcmRzID0gW2VsZW1lbnQueCwgZWxlbWVudC55XTtcblxuICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIFxuICAgICAgaWYgKGlzQXJyYXlJbkFycmF5KHJlc3VsdC5wb2ludHMsIGNvb3JkcykgPT0gdHJ1ZSl7XG4gICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSByZXN1bHQuY2x1c3RlcjtcbiAgICAgIH07XG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgZmlsbF9pbl90YWJsZSAoZGl2aWQsIGRhdGEsIGFsbF9wYXJ0aWNpcGFudHMsIHJlbW92ZWRfdG9vbHMpO1xuICBzZXRfY2VsbF9jb2xvcnMoZGl2aWQsIGxlZ2VuZF9jb2xvcl9wYWxldHRlLCByZW1vdmVkX3Rvb2xzKTtcblxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplX2RhdGEoeF92YWx1ZXMsIHlfdmFsdWVzKXtcblxuICAgIGxldCBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeF92YWx1ZXMpO1xuICAgIGxldCBtYXhZID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeV92YWx1ZXMpO1xuICAgIFxuICAgIGxldCB4X25vcm0gPSB4X3ZhbHVlcy5tYXAoZnVuY3Rpb24oZSkgeyAgXG4gICAgICByZXR1cm4gZSAvIG1heFg7XG4gICAgfSk7XG4gIFxuICAgIGxldCB5X25vcm0gPSB5X3ZhbHVlcy5tYXAoZnVuY3Rpb24oZSkgeyAgXG4gICAgICByZXR1cm4gZSAvIG1heFk7XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBbeF9ub3JtLCB5X25vcm1dO1xuICB9O1xuICBcbmZ1bmN0aW9uIHNvcnRCeUtleShhcnJheSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB2YXIgeCA9IGFba2V5XTsgdmFyIHkgPSBiW2tleV07XG4gICAgICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpICogLTE7XG4gICAgfSk7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBpc0FycmF5SW5BcnJheShhcnIsIGl0ZW0pe1xuICAgIHZhciBpdGVtX2FzX3N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICBcbiAgICB2YXIgY29udGFpbnMgPSBhcnIuc29tZShmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVsZSkgPT09IGl0ZW1fYXNfc3RyaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250YWlucztcbiAgfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/clusters.js\n");

/***/ }),

/***/ "./src/diagonals.js":
/*!**************************!*\
  !*** ./src/diagonals.js ***!
  \**************************/
/*! exports provided: get_diagonal_quartiles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_diagonal_quartiles\", function() { return get_diagonal_quartiles; });\n/* harmony import */ var _remove_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove_tools */ \"./src/remove_tools.js\");\n/* harmony import */ var _table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table */ \"./src/table.js\");\n\n\n\nfunction get_diagonal_quartiles(data, svg, xScale, yScale, div, width, height, removed_tools, better, divid, transform_to_table, legend_color_palette) {\n\n    let tools_not_hidden = Object(_remove_tools__WEBPACK_IMPORTED_MODULE_0__[\"remove_hidden_tools\"])(data, removed_tools);\n  \n    let x_values = tools_not_hidden.map(a => a.x);\n    let y_values = tools_not_hidden.map(a => a.y);\n  \n    // get distance to lowest score corner\n  \n    // normalize data to 0-1 range\n    let normalized_values = normalize_data(x_values, y_values);\n    let [x_norm, y_norm] = [normalized_values[0], normalized_values[1]];\n    \n    let max_x = Math.max.apply(null, x_values);\n    let max_y = Math.max.apply(null, y_values);\n  \n    // # compute the scores for each of the tool. based on their distance to the x and y axis\n    let scores = []\n    let scores_coords = {}; //this object will store the scores and the coordinates\n    for (let i = 0; i < x_norm.length; i++) {\n  \n      if (better == \"bottom-right\"){\n        scores.push(x_norm[i] + (1 - y_norm[i]));\n        scores_coords[x_norm[i] + (1 - y_norm[i])] =  [x_values[i], y_values[i]];\n        //append the score to the data array\n        tools_not_hidden[i]['score'] = x_norm[i] + (1 - y_norm[i]);\n      } \n      else if (better == \"top-right\"){\n        scores.push(x_norm[i] + y_norm[i]);\n        scores_coords[x_norm[i] + y_norm[i]] = [x_values[i], y_values[i]];\n        //append the score to the data array\n        tools_not_hidden[i]['score'] = x_norm[i] + y_norm[i];\n      };\n  \n    };\n  \n    // sort the scores and compute quartiles\n    scores.sort(function(a, b){return b-a});\n  \n    let first_quartile = d3.quantile(scores, 0.25);\n    let second_quartile = d3.quantile(scores, 0.5);\n    let third_quartile = d3.quantile(scores, 0.75);\n  \n    // compute the diagonal line coords\n    let coords = [get_diagonal_line(scores, scores_coords, first_quartile, better, max_x, max_y,svg, xScale, yScale), \n                  get_diagonal_line(scores, scores_coords, second_quartile, better, max_x, max_y,svg, xScale, yScale), \n                  get_diagonal_line(scores, scores_coords, third_quartile, better, max_x, max_y,svg, xScale, yScale)\n                ];\n    \n    // append the 3 lines to the svg\n    let index = 0;\n  \n    coords.forEach(line => {\n      let [x_coords, y_coords] = [line[0], line[1]];\n      svg.append(\"line\")\n         .attr(\"clip-path\",\"url(#clip)\")\n         .attr(\"x1\", xScale(x_coords[0]))\n         .attr(\"y1\", yScale(y_coords[0]))\n         .attr(\"x2\", xScale(x_coords[1]))\n         .attr(\"y2\", yScale(y_coords[1]))  \n         .attr(\"id\", function (d) { return divid+\"___diag_quartile_\" + index;})\n         .attr(\"stroke\", \"#0A58A2\")\n         .attr(\"stroke-width\",2)\n         .style(\"stroke-dasharray\", (\"20, 5\"))\n         .style(\"opacity\", 0.4)\n  \n      svg.append(\"clipPath\")\n         .attr(\"id\", \"clip\")\n         .append(\"rect\")\n         .attr(\"width\", width)\n         .attr(\"height\", height);\n  \n      index += 1;\n    });\n  \n    //the tranformation to tabular format is done only if there are any table elements in the html file\n    if (transform_to_table == true) {\n      transform_diag_classif_to_table(tools_not_hidden, first_quartile, second_quartile, third_quartile, divid,svg, xScale, yScale, legend_color_palette, data, removed_tools);\n    };\n  \n  };\n  \n  function transform_diag_classif_to_table(data, first_quartile, second_quartile, third_quartile, divid,svg, xScale, yScale, legend_color_palette, all_participants, removed_tools){\n  \n    let poly = [[],[],[],[]]\n    data.forEach(function(element) {\n  \n      if (element['score'] > first_quartile){\n            element['quartile'] = 1;\n            poly[0].push([element['x'], element['y']]);\n      }else if ( element['score'] > second_quartile && element['score'] <= first_quartile){\n            element['quartile'] = 2;\n            poly[1].push([element['x'], element['y']]);\n      }else if ( element['score'] > third_quartile && element['score'] <= second_quartile){\n            element['quartile'] = 3;\n            poly[2].push([element['x'], element['y']]);\n      }else if (element['score'] <= third_quartile){\n            element['quartile'] = 4;\n            poly[3].push([element['x'], element['y']]);\n      }\n    });\n    let i = 1;\n    poly.forEach(function(group) {\n  \n      var center = getCentroid(group);\n  \n      svg.append(\"text\")\n          .attr(\"class\", function (d) { return divid+\"___diag_num\";})\n          .attr(\"x\", xScale(center[0]))\n          .attr(\"y\", yScale(center[1]))\n          .style(\"opacity\", 0.4)\n          .style(\"font-size\", \"2vw\")\n          .style(\"fill\", \"#0A58A2\")\n          .text(i);\n      i++;\n  \n    });\n  \n    Object(_table__WEBPACK_IMPORTED_MODULE_1__[\"fill_in_table\"]) (divid, data, all_participants, removed_tools);\n    Object(_table__WEBPACK_IMPORTED_MODULE_1__[\"set_cell_colors\"])(divid, legend_color_palette, removed_tools);\n  \n  };\n  \n  function getCentroid(coord) \n  {\n      var center = coord.reduce(function (x,y) {\n          return [x[0] + y[0]/coord.length, x[1] + y[1]/coord.length] \n      }, [0,0])\n      return center;\n  }\n  \n  function normalize_data(x_values, y_values){\n  \n    let maxX = Math.max.apply(null, x_values);\n    let maxY = Math.max.apply(null, y_values);\n    \n    let x_norm = x_values.map(function(e) {  \n      return e / maxX;\n    });\n  \n    let y_norm = y_values.map(function(e) {  \n      return e / maxY;\n    });\n  \n    return [x_norm, y_norm];\n  };\n  \n  function get_diagonal_line(scores, scores_coords, quartile, better, max_x, max_y,svg, xScale, yScale){\n  \n    let target;\n    for (let i = 0; i < scores.length; i++) {\n      // # find out which are the two points that contain the percentile value\n      \n      if (scores[i] <= quartile){\n          target = [[scores_coords[scores[i - 1]][0], scores_coords[scores[i - 1]][1]],\n                    [scores_coords[scores[i]][0], scores_coords[scores[i]][1]]];\n          break;\n      };\n    };\n    // # get the the mid point between the two, where the quartile line will pass\n    let half_point = [(target[0][0] + target[1][0]) / 2, (target[0][1] + target[1][1]) / 2];\n  \n    // # draw the line depending on which is the optimal corner\n    let x_coords;\n    let y_coords;\n    if (better == \"bottom-right\"){\n         x_coords = [half_point[0] - 2*max_x, half_point[0] + 2*max_x];\n         y_coords = [half_point[1] - 2*max_y, half_point[1] + 2*max_y];\n    } else if (better == \"top-right\"){\n         x_coords = [half_point[0] + 2*max_x, half_point[0] - 2*max_x];\n         y_coords = [half_point[1] - 2*max_y, half_point[1] + 2*max_y];   \n    };\n  \n    return [x_coords, y_coords];\n  };\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGlhZ29uYWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2RpYWdvbmFscy5qcz8wZmE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbW92ZV9oaWRkZW5fdG9vbHN9IGZyb20gXCIuL3JlbW92ZV90b29sc1wiO1xuaW1wb3J0IHsgZmlsbF9pbl90YWJsZSwgc2V0X2NlbGxfY29sb3JzIH0gZnJvbSBcIi4vdGFibGVcIlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2RpYWdvbmFsX3F1YXJ0aWxlcyhkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBkaXYsIHdpZHRoLCBoZWlnaHQsIHJlbW92ZWRfdG9vbHMsIGJldHRlciwgZGl2aWQsIHRyYW5zZm9ybV90b190YWJsZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpIHtcblxuICAgIGxldCB0b29sc19ub3RfaGlkZGVuID0gcmVtb3ZlX2hpZGRlbl90b29scyhkYXRhLCByZW1vdmVkX3Rvb2xzKTtcbiAgXG4gICAgbGV0IHhfdmFsdWVzID0gdG9vbHNfbm90X2hpZGRlbi5tYXAoYSA9PiBhLngpO1xuICAgIGxldCB5X3ZhbHVlcyA9IHRvb2xzX25vdF9oaWRkZW4ubWFwKGEgPT4gYS55KTtcbiAgXG4gICAgLy8gZ2V0IGRpc3RhbmNlIHRvIGxvd2VzdCBzY29yZSBjb3JuZXJcbiAgXG4gICAgLy8gbm9ybWFsaXplIGRhdGEgdG8gMC0xIHJhbmdlXG4gICAgbGV0IG5vcm1hbGl6ZWRfdmFsdWVzID0gbm9ybWFsaXplX2RhdGEoeF92YWx1ZXMsIHlfdmFsdWVzKTtcbiAgICBsZXQgW3hfbm9ybSwgeV9ub3JtXSA9IFtub3JtYWxpemVkX3ZhbHVlc1swXSwgbm9ybWFsaXplZF92YWx1ZXNbMV1dO1xuICAgIFxuICAgIGxldCBtYXhfeCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhfdmFsdWVzKTtcbiAgICBsZXQgbWF4X3kgPSBNYXRoLm1heC5hcHBseShudWxsLCB5X3ZhbHVlcyk7XG4gIFxuICAgIC8vICMgY29tcHV0ZSB0aGUgc2NvcmVzIGZvciBlYWNoIG9mIHRoZSB0b29sLiBiYXNlZCBvbiB0aGVpciBkaXN0YW5jZSB0byB0aGUgeCBhbmQgeSBheGlzXG4gICAgbGV0IHNjb3JlcyA9IFtdXG4gICAgbGV0IHNjb3Jlc19jb29yZHMgPSB7fTsgLy90aGlzIG9iamVjdCB3aWxsIHN0b3JlIHRoZSBzY29yZXMgYW5kIHRoZSBjb29yZGluYXRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeF9ub3JtLmxlbmd0aDsgaSsrKSB7XG4gIFxuICAgICAgaWYgKGJldHRlciA9PSBcImJvdHRvbS1yaWdodFwiKXtcbiAgICAgICAgc2NvcmVzLnB1c2goeF9ub3JtW2ldICsgKDEgLSB5X25vcm1baV0pKTtcbiAgICAgICAgc2NvcmVzX2Nvb3Jkc1t4X25vcm1baV0gKyAoMSAtIHlfbm9ybVtpXSldID0gIFt4X3ZhbHVlc1tpXSwgeV92YWx1ZXNbaV1dO1xuICAgICAgICAvL2FwcGVuZCB0aGUgc2NvcmUgdG8gdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgdG9vbHNfbm90X2hpZGRlbltpXVsnc2NvcmUnXSA9IHhfbm9ybVtpXSArICgxIC0geV9ub3JtW2ldKTtcbiAgICAgIH0gXG4gICAgICBlbHNlIGlmIChiZXR0ZXIgPT0gXCJ0b3AtcmlnaHRcIil7XG4gICAgICAgIHNjb3Jlcy5wdXNoKHhfbm9ybVtpXSArIHlfbm9ybVtpXSk7XG4gICAgICAgIHNjb3Jlc19jb29yZHNbeF9ub3JtW2ldICsgeV9ub3JtW2ldXSA9IFt4X3ZhbHVlc1tpXSwgeV92YWx1ZXNbaV1dO1xuICAgICAgICAvL2FwcGVuZCB0aGUgc2NvcmUgdG8gdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgdG9vbHNfbm90X2hpZGRlbltpXVsnc2NvcmUnXSA9IHhfbm9ybVtpXSArIHlfbm9ybVtpXTtcbiAgICAgIH07XG4gIFxuICAgIH07XG4gIFxuICAgIC8vIHNvcnQgdGhlIHNjb3JlcyBhbmQgY29tcHV0ZSBxdWFydGlsZXNcbiAgICBzY29yZXMuc29ydChmdW5jdGlvbihhLCBiKXtyZXR1cm4gYi1hfSk7XG4gIFxuICAgIGxldCBmaXJzdF9xdWFydGlsZSA9IGQzLnF1YW50aWxlKHNjb3JlcywgMC4yNSk7XG4gICAgbGV0IHNlY29uZF9xdWFydGlsZSA9IGQzLnF1YW50aWxlKHNjb3JlcywgMC41KTtcbiAgICBsZXQgdGhpcmRfcXVhcnRpbGUgPSBkMy5xdWFudGlsZShzY29yZXMsIDAuNzUpO1xuICBcbiAgICAvLyBjb21wdXRlIHRoZSBkaWFnb25hbCBsaW5lIGNvb3Jkc1xuICAgIGxldCBjb29yZHMgPSBbZ2V0X2RpYWdvbmFsX2xpbmUoc2NvcmVzLCBzY29yZXNfY29vcmRzLCBmaXJzdF9xdWFydGlsZSwgYmV0dGVyLCBtYXhfeCwgbWF4X3ksc3ZnLCB4U2NhbGUsIHlTY2FsZSksIFxuICAgICAgICAgICAgICAgICAgZ2V0X2RpYWdvbmFsX2xpbmUoc2NvcmVzLCBzY29yZXNfY29vcmRzLCBzZWNvbmRfcXVhcnRpbGUsIGJldHRlciwgbWF4X3gsIG1heF95LHN2ZywgeFNjYWxlLCB5U2NhbGUpLCBcbiAgICAgICAgICAgICAgICAgIGdldF9kaWFnb25hbF9saW5lKHNjb3Jlcywgc2NvcmVzX2Nvb3JkcywgdGhpcmRfcXVhcnRpbGUsIGJldHRlciwgbWF4X3gsIG1heF95LHN2ZywgeFNjYWxlLCB5U2NhbGUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICBcbiAgICAvLyBhcHBlbmQgdGhlIDMgbGluZXMgdG8gdGhlIHN2Z1xuICAgIGxldCBpbmRleCA9IDA7XG4gIFxuICAgIGNvb3Jkcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgbGV0IFt4X2Nvb3JkcywgeV9jb29yZHNdID0gW2xpbmVbMF0sIGxpbmVbMV1dO1xuICAgICAgc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgIC5hdHRyKFwiY2xpcC1wYXRoXCIsXCJ1cmwoI2NsaXApXCIpXG4gICAgICAgICAuYXR0cihcIngxXCIsIHhTY2FsZSh4X2Nvb3Jkc1swXSkpXG4gICAgICAgICAuYXR0cihcInkxXCIsIHlTY2FsZSh5X2Nvb3Jkc1swXSkpXG4gICAgICAgICAuYXR0cihcIngyXCIsIHhTY2FsZSh4X2Nvb3Jkc1sxXSkpXG4gICAgICAgICAuYXR0cihcInkyXCIsIHlTY2FsZSh5X2Nvb3Jkc1sxXSkpICBcbiAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fZGlhZ19xdWFydGlsZV9cIiArIGluZGV4O30pXG4gICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwQTU4QTJcIilcbiAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMilcbiAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgKFwiMjAsIDVcIikpXG4gICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgXG4gICAgICBzdmcuYXBwZW5kKFwiY2xpcFBhdGhcIilcbiAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG4gICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIFxuICAgICAgaW5kZXggKz0gMTtcbiAgICB9KTtcbiAgXG4gICAgLy90aGUgdHJhbmZvcm1hdGlvbiB0byB0YWJ1bGFyIGZvcm1hdCBpcyBkb25lIG9ubHkgaWYgdGhlcmUgYXJlIGFueSB0YWJsZSBlbGVtZW50cyBpbiB0aGUgaHRtbCBmaWxlXG4gICAgaWYgKHRyYW5zZm9ybV90b190YWJsZSA9PSB0cnVlKSB7XG4gICAgICB0cmFuc2Zvcm1fZGlhZ19jbGFzc2lmX3RvX3RhYmxlKHRvb2xzX25vdF9oaWRkZW4sIGZpcnN0X3F1YXJ0aWxlLCBzZWNvbmRfcXVhcnRpbGUsIHRoaXJkX3F1YXJ0aWxlLCBkaXZpZCxzdmcsIHhTY2FsZSwgeVNjYWxlLCBsZWdlbmRfY29sb3JfcGFsZXR0ZSwgZGF0YSwgcmVtb3ZlZF90b29scyk7XG4gICAgfTtcbiAgXG4gIH07XG4gIFxuICBmdW5jdGlvbiB0cmFuc2Zvcm1fZGlhZ19jbGFzc2lmX3RvX3RhYmxlKGRhdGEsIGZpcnN0X3F1YXJ0aWxlLCBzZWNvbmRfcXVhcnRpbGUsIHRoaXJkX3F1YXJ0aWxlLCBkaXZpZCxzdmcsIHhTY2FsZSwgeVNjYWxlLCBsZWdlbmRfY29sb3JfcGFsZXR0ZSwgYWxsX3BhcnRpY2lwYW50cywgcmVtb3ZlZF90b29scyl7XG4gIFxuICAgIGxldCBwb2x5ID0gW1tdLFtdLFtdLFtdXVxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gIFxuICAgICAgaWYgKGVsZW1lbnRbJ3Njb3JlJ10gPiBmaXJzdF9xdWFydGlsZSl7XG4gICAgICAgICAgICBlbGVtZW50WydxdWFydGlsZSddID0gMTtcbiAgICAgICAgICAgIHBvbHlbMF0ucHVzaChbZWxlbWVudFsneCddLCBlbGVtZW50Wyd5J11dKTtcbiAgICAgIH1lbHNlIGlmICggZWxlbWVudFsnc2NvcmUnXSA+IHNlY29uZF9xdWFydGlsZSAmJiBlbGVtZW50WydzY29yZSddIDw9IGZpcnN0X3F1YXJ0aWxlKXtcbiAgICAgICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSAyO1xuICAgICAgICAgICAgcG9seVsxXS5wdXNoKFtlbGVtZW50Wyd4J10sIGVsZW1lbnRbJ3knXV0pO1xuICAgICAgfWVsc2UgaWYgKCBlbGVtZW50WydzY29yZSddID4gdGhpcmRfcXVhcnRpbGUgJiYgZWxlbWVudFsnc2NvcmUnXSA8PSBzZWNvbmRfcXVhcnRpbGUpe1xuICAgICAgICAgICAgZWxlbWVudFsncXVhcnRpbGUnXSA9IDM7XG4gICAgICAgICAgICBwb2x5WzJdLnB1c2goW2VsZW1lbnRbJ3gnXSwgZWxlbWVudFsneSddXSk7XG4gICAgICB9ZWxzZSBpZiAoZWxlbWVudFsnc2NvcmUnXSA8PSB0aGlyZF9xdWFydGlsZSl7XG4gICAgICAgICAgICBlbGVtZW50WydxdWFydGlsZSddID0gNDtcbiAgICAgICAgICAgIHBvbHlbM10ucHVzaChbZWxlbWVudFsneCddLCBlbGVtZW50Wyd5J11dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgaSA9IDE7XG4gICAgcG9seS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gIFxuICAgICAgdmFyIGNlbnRlciA9IGdldENlbnRyb2lkKGdyb3VwKTtcbiAgXG4gICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fZGlhZ19udW1cIjt9KVxuICAgICAgICAgIC5hdHRyKFwieFwiLCB4U2NhbGUoY2VudGVyWzBdKSlcbiAgICAgICAgICAuYXR0cihcInlcIiwgeVNjYWxlKGNlbnRlclsxXSkpXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjQpXG4gICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMnZ3XCIpXG4gICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiMwQTU4QTJcIilcbiAgICAgICAgICAudGV4dChpKTtcbiAgICAgIGkrKztcbiAgXG4gICAgfSk7XG4gIFxuICAgIGZpbGxfaW5fdGFibGUgKGRpdmlkLCBkYXRhLCBhbGxfcGFydGljaXBhbnRzLCByZW1vdmVkX3Rvb2xzKTtcbiAgICBzZXRfY2VsbF9jb2xvcnMoZGl2aWQsIGxlZ2VuZF9jb2xvcl9wYWxldHRlLCByZW1vdmVkX3Rvb2xzKTtcbiAgXG4gIH07XG4gIFxuICBmdW5jdGlvbiBnZXRDZW50cm9pZChjb29yZCkgXG4gIHtcbiAgICAgIHZhciBjZW50ZXIgPSBjb29yZC5yZWR1Y2UoZnVuY3Rpb24gKHgseSkge1xuICAgICAgICAgIHJldHVybiBbeFswXSArIHlbMF0vY29vcmQubGVuZ3RoLCB4WzFdICsgeVsxXS9jb29yZC5sZW5ndGhdIFxuICAgICAgfSwgWzAsMF0pXG4gICAgICByZXR1cm4gY2VudGVyO1xuICB9XG4gIFxuICBmdW5jdGlvbiBub3JtYWxpemVfZGF0YSh4X3ZhbHVlcywgeV92YWx1ZXMpe1xuICBcbiAgICBsZXQgbWF4WCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhfdmFsdWVzKTtcbiAgICBsZXQgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHlfdmFsdWVzKTtcbiAgICBcbiAgICBsZXQgeF9ub3JtID0geF92YWx1ZXMubWFwKGZ1bmN0aW9uKGUpIHsgIFxuICAgICAgcmV0dXJuIGUgLyBtYXhYO1xuICAgIH0pO1xuICBcbiAgICBsZXQgeV9ub3JtID0geV92YWx1ZXMubWFwKGZ1bmN0aW9uKGUpIHsgIFxuICAgICAgcmV0dXJuIGUgLyBtYXhZO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gW3hfbm9ybSwgeV9ub3JtXTtcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGdldF9kaWFnb25hbF9saW5lKHNjb3Jlcywgc2NvcmVzX2Nvb3JkcywgcXVhcnRpbGUsIGJldHRlciwgbWF4X3gsIG1heF95LHN2ZywgeFNjYWxlLCB5U2NhbGUpe1xuICBcbiAgICBsZXQgdGFyZ2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyAjIGZpbmQgb3V0IHdoaWNoIGFyZSB0aGUgdHdvIHBvaW50cyB0aGF0IGNvbnRhaW4gdGhlIHBlcmNlbnRpbGUgdmFsdWVcbiAgICAgIFxuICAgICAgaWYgKHNjb3Jlc1tpXSA8PSBxdWFydGlsZSl7XG4gICAgICAgICAgdGFyZ2V0ID0gW1tzY29yZXNfY29vcmRzW3Njb3Jlc1tpIC0gMV1dWzBdLCBzY29yZXNfY29vcmRzW3Njb3Jlc1tpIC0gMV1dWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgW3Njb3Jlc19jb29yZHNbc2NvcmVzW2ldXVswXSwgc2NvcmVzX2Nvb3Jkc1tzY29yZXNbaV1dWzFdXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9O1xuICAgIH07XG4gICAgLy8gIyBnZXQgdGhlIHRoZSBtaWQgcG9pbnQgYmV0d2VlbiB0aGUgdHdvLCB3aGVyZSB0aGUgcXVhcnRpbGUgbGluZSB3aWxsIHBhc3NcbiAgICBsZXQgaGFsZl9wb2ludCA9IFsodGFyZ2V0WzBdWzBdICsgdGFyZ2V0WzFdWzBdKSAvIDIsICh0YXJnZXRbMF1bMV0gKyB0YXJnZXRbMV1bMV0pIC8gMl07XG4gIFxuICAgIC8vICMgZHJhdyB0aGUgbGluZSBkZXBlbmRpbmcgb24gd2hpY2ggaXMgdGhlIG9wdGltYWwgY29ybmVyXG4gICAgbGV0IHhfY29vcmRzO1xuICAgIGxldCB5X2Nvb3JkcztcbiAgICBpZiAoYmV0dGVyID09IFwiYm90dG9tLXJpZ2h0XCIpe1xuICAgICAgICAgeF9jb29yZHMgPSBbaGFsZl9wb2ludFswXSAtIDIqbWF4X3gsIGhhbGZfcG9pbnRbMF0gKyAyKm1heF94XTtcbiAgICAgICAgIHlfY29vcmRzID0gW2hhbGZfcG9pbnRbMV0gLSAyKm1heF95LCBoYWxmX3BvaW50WzFdICsgMiptYXhfeV07XG4gICAgfSBlbHNlIGlmIChiZXR0ZXIgPT0gXCJ0b3AtcmlnaHRcIil7XG4gICAgICAgICB4X2Nvb3JkcyA9IFtoYWxmX3BvaW50WzBdICsgMiptYXhfeCwgaGFsZl9wb2ludFswXSAtIDIqbWF4X3hdO1xuICAgICAgICAgeV9jb29yZHMgPSBbaGFsZl9wb2ludFsxXSAtIDIqbWF4X3ksIGhhbGZfcG9pbnRbMV0gKyAyKm1heF95XTsgICBcbiAgICB9O1xuICBcbiAgICByZXR1cm4gW3hfY29vcmRzLCB5X2Nvb3Jkc107XG4gIH07XG4gICJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/diagonals.js\n");

/***/ }),

/***/ "./src/legend.js":
/*!***********************!*\
  !*** ./src/legend.js ***!
  \***********************/
/*! exports provided: draw_legend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draw_legend\", function() { return draw_legend; });\n/* harmony import */ var _classification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classification */ \"./src/classification.js\");\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n\n\n\nfunction draw_legend (data, svg, xScale, yScale, div, width, height, removed_tools, color, color_domain, divid,classification_type, legend_color_palette) {\n  \n    //set number of elements per legend row\n    let n = 4;\n  \n    let legend = svg.selectAll(\".legend\")\n      .data(color_domain)\n      .enter().append(\"g\")\n      .attr(\"class\", \"legend\")\n      .attr(\"transform\", function(d, i) { return \"translate(\" + (-width+i%n*(Math.round($(window).width()* 0.16))) + \",\" + (height + (Math.round($(window).height()* 0.0862962)) + Math.floor(i/n) * (Math.round($(window).height()* 0.0251481))) + \")\"; });\n\n    // draw legend colored rectangles    \n    legend.append(\"rect\")\n          .attr(\"x\", width + Math.round($(window).width()* 0.010227))\n          .attr(\"width\", Math.round($(window).width()* 0.010227))\n          .attr(\"height\", Math.round($(window).height()* 0.020833))\n          .attr(\"id\", function (d) { return divid+\"___leg_rect\"+d.replace(/[\\. ()/-]/g, \"_\");})\n          .attr(\"class\", \"benchmark_legend_rect\")\n          .style(\"fill\", color)\n          .on('click', function(d) {\n            \n            let dot = d3.select(\"text#\" +divid+\"___\"+d.replace(/[\\. ()/-]/g, \"_\"));\n            let ID = dot._groups[0][0].id;\n  \n            if(data.length-removed_tools.length-1 >= 4){\n  \n              let legend_rect = this;\n              show_or_hide_participant_in_plot (ID, data, svg, xScale, yScale, div, width, height, removed_tools,divid,classification_type, legend_rect, legend_color_palette);\n  \n            } else if (data.length-removed_tools.length-1 < 4 && (d3.select(\"#\"+ID).style(\"opacity\")) == 0){\n  \n              let legend_rect = this;\n              show_or_hide_participant_in_plot (ID, data, svg, xScale, yScale, div, width, height, removed_tools,divid,classification_type, legend_rect, legend_color_palette);\n  \n            } else {\n              \n              $('.removal_alert').remove();\n              var alert_msg = $('<div class=\"removal_alert\">\\\n                                  <span class=\"closebtn\" onclick=\"(this.parentNode.remove());\">&times;</span>\\\n                                  At least four participants are required for the benchmark!!\\\n                                </div>');\n              $(\"#\" + divid).append(alert_msg);\n  \n              setTimeout(function(){\n                if ($('.removal_alert').length > 0) {\n                  $('.removal_alert').remove();\n                }\n              }, 5000)\n  \n            };\n          })\n          .on(\"mouseover\", function (d) {\n  \n            let dot = d3.select(\"text#\" +divid+\"___\"+d.replace(/[\\. ()/-]/g, \"_\"));\n            let ID = dot._groups[0][0].id;\n            let tool_id =ID.split(\"___\")[1];\n  \n            if (d3.select(\"#\"+ID).style(\"opacity\") == 0){\n              d3.select(this).style(\"opacity\", 1);\n              d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 1);\n            } else {\n              d3.select(this).style(\"opacity\", 0.2);\n              d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 0.2);\n            };\n            \n          }) \n          .on(\"mouseout\", function (d) {\n  \n            let dot = d3.select(\"text#\" +divid+\"___\"+d.replace(/[\\. ()/-]/g, \"_\"));\n            let ID = dot._groups[0][0].id;\n            let tool_id =ID.split(\"___\")[1];\n  \n            if (d3.select(\"#\"+ID).style(\"opacity\") == 0){\n              d3.select(this).style(\"opacity\", 0.2);\n              d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 0.2);\n            } else {\n              d3.select(this).style(\"opacity\", 1);\n              d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 1);\n            };\n          });\n  \n    // draw legend text\n    legend.append(\"text\")\n          .attr(\"x\", width + Math.round($(window).width()* 0.022727))\n          .attr(\"y\", Math.round($(window).height()* 0.01041))\n          .attr(\"id\", function (d) { return divid+\"___\"+d.replace(/[\\. ()/-]/g, \"_\");})\n          .attr(\"dy\", \".35em\")\n          .style(\"text-anchor\", \"start\")\n          .style(\"font-size\", \"1vw\")\n          .text(function(d) {\n            return d;\n          });\n    \n  let symbol = d3.symbol();\n  var shapeScale = d3.scaleOrdinal()\n          .domain(data.map(d => d.toolname))\n          .range(Array(Math.ceil(data.length/7)).fill([d3.symbolCircle, d3.symbolCross, d3.symbolDiamond, d3.symbolSquare, d3.symbolStar, d3.symbolTriangle, d3.symbolWye]).flat());\n\n  svg.selectAll(\".benchmark_legend_rect\")\n  .data(data)\n    .enter()\n    .append(\"path\")\n  .style(\"fill\", color)\n    .attr(\"d\", symbol.type(function(d){return shapeScale(d.toolname)}).size(2000))\n\n  };\n  \n\nfunction show_or_hide_participant_in_plot (ID, data, svg, xScale, yScale, div, width, height, removed_tools,divid,classification_type, legend_rect, legend_color_palette){\n\n    let tool_id =ID.split(\"___\")[1];\n   // remove the existing number and classification lines from plot (if any)\n   svg.selectAll(\"#\"+divid+\"___x_quartile\").remove();\n   svg.selectAll(\"#\"+divid+\"___y_quartile\").remove();\n   svg.selectAll(\"#\"+divid+\"___diag_quartile_0\").remove();\n   svg.selectAll(\"#\"+divid+\"___diag_quartile_1\").remove();\n   svg.selectAll(\"#\"+divid+\"___diag_quartile_2\").remove();\n   svg.selectAll(\"#\"+divid+\"___num_bottom_right\").remove();\n   svg.selectAll(\"#\"+divid+\"___num_top_right\").remove();\n   svg.selectAll(\"#\"+divid+\"___num_bottom_left\").remove();\n   svg.selectAll(\"#\"+divid+\"___num_top_left\").remove();\n   svg.selectAll(\"#\"+divid+\"___pareto\" ).remove();\n   svg.selectAll(\".\"+divid+\"___diag_num\").remove();\n   svg.selectAll(\".\"+divid+\"___cluster_num\").remove();\n   svg.selectAll(\".\"+divid+\"___clust_lines\").remove();\n   svg.selectAll(\".\"+divid+\"___clust_polygons\").remove();\n   svg.selectAll(\".\"+divid+\"___better_annotation\").remove();\n \n   let blockopacity = d3.select(\"#\"+ID).style(\"opacity\");\n   \n   // change the opacity to 0 or 1 depending on the current state\n   if (blockopacity == 0) {\n     d3.select(\"#\"+ID).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___top\"+tool_id).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___bottom\"+tool_id).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___line\"+tool_id).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___lineX\"+tool_id).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___right\"+tool_id).style(\"opacity\", 1);\n     d3.select(\"#\"+divid+\"___left\"+tool_id).style(\"opacity\", 1);\n     // recalculate the quartiles after removing the tools\n     let index = $.inArray(tool_id.replace(/_/g, \"-\"), removed_tools);\n     removed_tools.splice(index, 1);\n     Object(_classification__WEBPACK_IMPORTED_MODULE_0__[\"compute_classification\"])(data, svg, xScale, yScale, div, width, height, removed_tools,divid,classification_type, legend_color_palette, _app__WEBPACK_IMPORTED_MODULE_1__[\"better\"][divid]);\n     //change the legend opacity to keep track of hidden tools\n     d3.select(legend_rect).style(\"opacity\", 1);\n     d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 1);\n \n   } else {\n     d3.select(\"#\"+ID).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___top\"+tool_id).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___bottom\"+tool_id).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___line\"+tool_id).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___lineX\"+tool_id).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___right\"+tool_id).style(\"opacity\", 0);\n     d3.select(\"#\"+divid+\"___left\"+tool_id).style(\"opacity\", 0);\n     removed_tools.push(tool_id.replace(/_/g, \"-\"));\n     Object(_classification__WEBPACK_IMPORTED_MODULE_0__[\"compute_classification\"])(data, svg, xScale, yScale, div, width, height, removed_tools,divid,classification_type, legend_color_palette, _app__WEBPACK_IMPORTED_MODULE_1__[\"better\"][divid]);\n     //change the legend opacity to keep track of hidden tools\n     d3.select(legend_rect).style(\"opacity\", 0.2);\n     d3.select(\"text#\" +divid+\"___\"+tool_id).style(\"opacity\", 0.2);\n   }\n \n };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGVnZW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xlZ2VuZC5qcz9hZGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXB1dGVfY2xhc3NpZmljYXRpb24gfSBmcm9tIFwiLi9jbGFzc2lmaWNhdGlvblwiO1xuaW1wb3J0IHsgYmV0dGVyIH0gZnJvbSBcIi4vYXBwXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdfbGVnZW5kIChkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBkaXYsIHdpZHRoLCBoZWlnaHQsIHJlbW92ZWRfdG9vbHMsIGNvbG9yLCBjb2xvcl9kb21haW4sIGRpdmlkLGNsYXNzaWZpY2F0aW9uX3R5cGUsIGxlZ2VuZF9jb2xvcl9wYWxldHRlKSB7XG4gIFxuICAgIC8vc2V0IG51bWJlciBvZiBlbGVtZW50cyBwZXIgbGVnZW5kIHJvd1xuICAgIGxldCBuID0gNDtcbiAgXG4gICAgbGV0IGxlZ2VuZCA9IHN2Zy5zZWxlY3RBbGwoXCIubGVnZW5kXCIpXG4gICAgICAuZGF0YShjb2xvcl9kb21haW4pXG4gICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArICgtd2lkdGgraSVuKihNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjE2KSkpICsgXCIsXCIgKyAoaGVpZ2h0ICsgKE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjA4NjI5NjIpKSArIE1hdGguZmxvb3IoaS9uKSAqIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMjUxNDgxKSkpICsgXCIpXCI7IH0pO1xuXG4gICAgLy8gZHJhdyBsZWdlbmQgY29sb3JlZCByZWN0YW5nbGVzICAgIFxuICAgIGxlZ2VuZC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoICsgTWF0aC5yb3VuZCgkKHdpbmRvdykud2lkdGgoKSogMC4wMTAyMjcpKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgTWF0aC5yb3VuZCgkKHdpbmRvdykud2lkdGgoKSogMC4wMTAyMjcpKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjAyMDgzMykpXG4gICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19sZWdfcmVjdFwiK2QucmVwbGFjZSgvW1xcLiAoKS8tXS9nLCBcIl9cIik7fSlcbiAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmVuY2htYXJrX2xlZ2VuZF9yZWN0XCIpXG4gICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcilcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZG90ID0gZDMuc2VsZWN0KFwidGV4dCNcIiArZGl2aWQrXCJfX19cIitkLnJlcGxhY2UoL1tcXC4gKCkvLV0vZywgXCJfXCIpKTtcbiAgICAgICAgICAgIGxldCBJRCA9IGRvdC5fZ3JvdXBzWzBdWzBdLmlkO1xuICBcbiAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoLXJlbW92ZWRfdG9vbHMubGVuZ3RoLTEgPj0gNCl7XG4gIFxuICAgICAgICAgICAgICBsZXQgbGVnZW5kX3JlY3QgPSB0aGlzO1xuICAgICAgICAgICAgICBzaG93X29yX2hpZGVfcGFydGljaXBhbnRfaW5fcGxvdCAoSUQsIGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgd2lkdGgsIGhlaWdodCwgcmVtb3ZlZF90b29scyxkaXZpZCxjbGFzc2lmaWNhdGlvbl90eXBlLCBsZWdlbmRfcmVjdCwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpO1xuICBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGgtcmVtb3ZlZF90b29scy5sZW5ndGgtMSA8IDQgJiYgKGQzLnNlbGVjdChcIiNcIitJRCkuc3R5bGUoXCJvcGFjaXR5XCIpKSA9PSAwKXtcbiAgXG4gICAgICAgICAgICAgIGxldCBsZWdlbmRfcmVjdCA9IHRoaXM7XG4gICAgICAgICAgICAgIHNob3dfb3JfaGlkZV9wYXJ0aWNpcGFudF9pbl9wbG90IChJRCwgZGF0YSwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgZGl2LCB3aWR0aCwgaGVpZ2h0LCByZW1vdmVkX3Rvb2xzLGRpdmlkLGNsYXNzaWZpY2F0aW9uX3R5cGUsIGxlZ2VuZF9yZWN0LCBsZWdlbmRfY29sb3JfcGFsZXR0ZSk7XG4gIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICQoJy5yZW1vdmFsX2FsZXJ0JykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIHZhciBhbGVydF9tc2cgPSAkKCc8ZGl2IGNsYXNzPVwicmVtb3ZhbF9hbGVydFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjbG9zZWJ0blwiIG9uY2xpY2s9XCIodGhpcy5wYXJlbnROb2RlLnJlbW92ZSgpKTtcIj4mdGltZXM7PC9zcGFuPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXQgbGVhc3QgZm91ciBwYXJ0aWNpcGFudHMgYXJlIHJlcXVpcmVkIGZvciB0aGUgYmVuY2htYXJrISFcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nKTtcbiAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmlkKS5hcHBlbmQoYWxlcnRfbXNnKTtcbiAgXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAoJCgnLnJlbW92YWxfYWxlcnQnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAkKCcucmVtb3ZhbF9hbGVydCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgNTAwMClcbiAgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gIFxuICAgICAgICAgICAgbGV0IGRvdCA9IGQzLnNlbGVjdChcInRleHQjXCIgK2RpdmlkK1wiX19fXCIrZC5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKSk7XG4gICAgICAgICAgICBsZXQgSUQgPSBkb3QuX2dyb3Vwc1swXVswXS5pZDtcbiAgICAgICAgICAgIGxldCB0b29sX2lkID1JRC5zcGxpdChcIl9fX1wiKVsxXTtcbiAgXG4gICAgICAgICAgICBpZiAoZDMuc2VsZWN0KFwiI1wiK0lEKS5zdHlsZShcIm9wYWNpdHlcIikgPT0gMCl7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdChcInRleHQjXCIgK2RpdmlkK1wiX19fXCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiLCAwLjIpO1xuICAgICAgICAgICAgICBkMy5zZWxlY3QoXCJ0ZXh0I1wiICtkaXZpZCtcIl9fX1wiK3Rvb2xfaWQpLnN0eWxlKFwib3BhY2l0eVwiLCAwLjIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0pIFxuICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChkKSB7XG4gIFxuICAgICAgICAgICAgbGV0IGRvdCA9IGQzLnNlbGVjdChcInRleHQjXCIgK2RpdmlkK1wiX19fXCIrZC5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKSk7XG4gICAgICAgICAgICBsZXQgSUQgPSBkb3QuX2dyb3Vwc1swXVswXS5pZDtcbiAgICAgICAgICAgIGxldCB0b29sX2lkID1JRC5zcGxpdChcIl9fX1wiKVsxXTtcbiAgXG4gICAgICAgICAgICBpZiAoZDMuc2VsZWN0KFwiI1wiK0lEKS5zdHlsZShcIm9wYWNpdHlcIikgPT0gMCl7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIiwgMC4yKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KFwidGV4dCNcIiArZGl2aWQrXCJfX19cIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMC4yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdChcInRleHQjXCIgK2RpdmlkK1wiX19fXCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgXG4gICAgLy8gZHJhdyBsZWdlbmQgdGV4dFxuICAgIGxlZ2VuZC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoICsgTWF0aC5yb3VuZCgkKHdpbmRvdykud2lkdGgoKSogMC4wMjI3MjcpKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMTA0MSkpXG4gICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19cIitkLnJlcGxhY2UoL1tcXC4gKCkvLV0vZywgXCJfXCIpO30pXG4gICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjF2d1wiKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgIFxuICBsZXQgc3ltYm9sID0gZDMuc3ltYm9sKCk7XG4gIHZhciBzaGFwZVNjYWxlID0gZDMuc2NhbGVPcmRpbmFsKClcbiAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4gZC50b29sbmFtZSkpXG4gICAgICAgICAgLnJhbmdlKEFycmF5KE1hdGguY2VpbChkYXRhLmxlbmd0aC83KSkuZmlsbChbZDMuc3ltYm9sQ2lyY2xlLCBkMy5zeW1ib2xDcm9zcywgZDMuc3ltYm9sRGlhbW9uZCwgZDMuc3ltYm9sU3F1YXJlLCBkMy5zeW1ib2xTdGFyLCBkMy5zeW1ib2xUcmlhbmdsZSwgZDMuc3ltYm9sV3llXSkuZmxhdCgpKTtcblxuICBzdmcuc2VsZWN0QWxsKFwiLmJlbmNobWFya19sZWdlbmRfcmVjdFwiKVxuICAuZGF0YShkYXRhKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcInBhdGhcIilcbiAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcilcbiAgICAuYXR0cihcImRcIiwgc3ltYm9sLnR5cGUoZnVuY3Rpb24oZCl7cmV0dXJuIHNoYXBlU2NhbGUoZC50b29sbmFtZSl9KS5zaXplKDIwMDApKVxuXG4gIH07XG4gIFxuXG5mdW5jdGlvbiBzaG93X29yX2hpZGVfcGFydGljaXBhbnRfaW5fcGxvdCAoSUQsIGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgd2lkdGgsIGhlaWdodCwgcmVtb3ZlZF90b29scyxkaXZpZCxjbGFzc2lmaWNhdGlvbl90eXBlLCBsZWdlbmRfcmVjdCwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpe1xuXG4gICAgbGV0IHRvb2xfaWQgPUlELnNwbGl0KFwiX19fXCIpWzFdO1xuICAgLy8gcmVtb3ZlIHRoZSBleGlzdGluZyBudW1iZXIgYW5kIGNsYXNzaWZpY2F0aW9uIGxpbmVzIGZyb20gcGxvdCAoaWYgYW55KVxuICAgc3ZnLnNlbGVjdEFsbChcIiNcIitkaXZpZCtcIl9fX3hfcXVhcnRpbGVcIikucmVtb3ZlKCk7XG4gICBzdmcuc2VsZWN0QWxsKFwiI1wiK2RpdmlkK1wiX19feV9xdWFydGlsZVwiKS5yZW1vdmUoKTtcbiAgIHN2Zy5zZWxlY3RBbGwoXCIjXCIrZGl2aWQrXCJfX19kaWFnX3F1YXJ0aWxlXzBcIikucmVtb3ZlKCk7XG4gICBzdmcuc2VsZWN0QWxsKFwiI1wiK2RpdmlkK1wiX19fZGlhZ19xdWFydGlsZV8xXCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIiNcIitkaXZpZCtcIl9fX2RpYWdfcXVhcnRpbGVfMlwiKS5yZW1vdmUoKTtcbiAgIHN2Zy5zZWxlY3RBbGwoXCIjXCIrZGl2aWQrXCJfX19udW1fYm90dG9tX3JpZ2h0XCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIiNcIitkaXZpZCtcIl9fX251bV90b3BfcmlnaHRcIikucmVtb3ZlKCk7XG4gICBzdmcuc2VsZWN0QWxsKFwiI1wiK2RpdmlkK1wiX19fbnVtX2JvdHRvbV9sZWZ0XCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIiNcIitkaXZpZCtcIl9fX251bV90b3BfbGVmdFwiKS5yZW1vdmUoKTtcbiAgIHN2Zy5zZWxlY3RBbGwoXCIjXCIrZGl2aWQrXCJfX19wYXJldG9cIiApLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIi5cIitkaXZpZCtcIl9fX2RpYWdfbnVtXCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIi5cIitkaXZpZCtcIl9fX2NsdXN0ZXJfbnVtXCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIi5cIitkaXZpZCtcIl9fX2NsdXN0X2xpbmVzXCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIi5cIitkaXZpZCtcIl9fX2NsdXN0X3BvbHlnb25zXCIpLnJlbW92ZSgpO1xuICAgc3ZnLnNlbGVjdEFsbChcIi5cIitkaXZpZCtcIl9fX2JldHRlcl9hbm5vdGF0aW9uXCIpLnJlbW92ZSgpO1xuIFxuICAgbGV0IGJsb2Nrb3BhY2l0eSA9IGQzLnNlbGVjdChcIiNcIitJRCkuc3R5bGUoXCJvcGFjaXR5XCIpO1xuICAgXG4gICAvLyBjaGFuZ2UgdGhlIG9wYWNpdHkgdG8gMCBvciAxIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBzdGF0ZVxuICAgaWYgKGJsb2Nrb3BhY2l0eSA9PSAwKSB7XG4gICAgIGQzLnNlbGVjdChcIiNcIitJRCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICBkMy5zZWxlY3QoXCIjXCIrZGl2aWQrXCJfX190b3BcIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgIGQzLnNlbGVjdChcIiNcIitkaXZpZCtcIl9fX2JvdHRvbVwiK3Rvb2xfaWQpLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgZDMuc2VsZWN0KFwiI1wiK2RpdmlkK1wiX19fbGluZVwiK3Rvb2xfaWQpLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgZDMuc2VsZWN0KFwiI1wiK2RpdmlkK1wiX19fbGluZVhcIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgIGQzLnNlbGVjdChcIiNcIitkaXZpZCtcIl9fX3JpZ2h0XCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICBkMy5zZWxlY3QoXCIjXCIrZGl2aWQrXCJfX19sZWZ0XCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAvLyByZWNhbGN1bGF0ZSB0aGUgcXVhcnRpbGVzIGFmdGVyIHJlbW92aW5nIHRoZSB0b29sc1xuICAgICBsZXQgaW5kZXggPSAkLmluQXJyYXkodG9vbF9pZC5yZXBsYWNlKC9fL2csIFwiLVwiKSwgcmVtb3ZlZF90b29scyk7XG4gICAgIHJlbW92ZWRfdG9vbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgY29tcHV0ZV9jbGFzc2lmaWNhdGlvbihkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBkaXYsIHdpZHRoLCBoZWlnaHQsIHJlbW92ZWRfdG9vbHMsZGl2aWQsY2xhc3NpZmljYXRpb25fdHlwZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIGJldHRlcltkaXZpZF0pO1xuICAgICAvL2NoYW5nZSB0aGUgbGVnZW5kIG9wYWNpdHkgdG8ga2VlcCB0cmFjayBvZiBoaWRkZW4gdG9vbHNcbiAgICAgZDMuc2VsZWN0KGxlZ2VuZF9yZWN0KS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgIGQzLnNlbGVjdChcInRleHQjXCIgK2RpdmlkK1wiX19fXCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuIFxuICAgfSBlbHNlIHtcbiAgICAgZDMuc2VsZWN0KFwiI1wiK0lEKS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgIGQzLnNlbGVjdChcIiNcIitkaXZpZCtcIl9fX3RvcFwiK3Rvb2xfaWQpLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgZDMuc2VsZWN0KFwiI1wiK2RpdmlkK1wiX19fYm90dG9tXCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICBkMy5zZWxlY3QoXCIjXCIrZGl2aWQrXCJfX19saW5lXCIrdG9vbF9pZCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICBkMy5zZWxlY3QoXCIjXCIrZGl2aWQrXCJfX19saW5lWFwiK3Rvb2xfaWQpLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgZDMuc2VsZWN0KFwiI1wiK2RpdmlkK1wiX19fcmlnaHRcIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgIGQzLnNlbGVjdChcIiNcIitkaXZpZCtcIl9fX2xlZnRcIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgIHJlbW92ZWRfdG9vbHMucHVzaCh0b29sX2lkLnJlcGxhY2UoL18vZywgXCItXCIpKTtcbiAgICAgY29tcHV0ZV9jbGFzc2lmaWNhdGlvbihkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBkaXYsIHdpZHRoLCBoZWlnaHQsIHJlbW92ZWRfdG9vbHMsZGl2aWQsY2xhc3NpZmljYXRpb25fdHlwZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIGJldHRlcltkaXZpZF0pO1xuICAgICAvL2NoYW5nZSB0aGUgbGVnZW5kIG9wYWNpdHkgdG8ga2VlcCB0cmFjayBvZiBoaWRkZW4gdG9vbHNcbiAgICAgZDMuc2VsZWN0KGxlZ2VuZF9yZWN0KS5zdHlsZShcIm9wYWNpdHlcIiwgMC4yKTtcbiAgICAgZDMuc2VsZWN0KFwidGV4dCNcIiArZGl2aWQrXCJfX19cIit0b29sX2lkKS5zdHlsZShcIm9wYWNpdHlcIiwgMC4yKTtcbiAgIH1cbiBcbiB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/legend.js\n");

/***/ }),

/***/ "./src/remove_tools.js":
/*!*****************************!*\
  !*** ./src/remove_tools.js ***!
  \*****************************/
/*! exports provided: remove_hidden_tools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"remove_hidden_tools\", function() { return remove_hidden_tools; });\n\nfunction remove_hidden_tools(data, removed_tools){\n  // remove from the data array the participants that the user has hidden (removed_tools)\n  // create a new array where the tools that have not been hidden will be stored\n  let tools_not_hidden = [];\n  data.forEach(element => {\n    let index = $.inArray(element.toolname.replace(/[\\. ()/_]/g, \"-\"), removed_tools);\n    if (index == -1){\n      tools_not_hidden.push(element);\n    }\n  });\n\n  return tools_not_hidden;\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVtb3ZlX3Rvb2xzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlbW92ZV90b29scy5qcz9lNjFlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9oaWRkZW5fdG9vbHMoZGF0YSwgcmVtb3ZlZF90b29scyl7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBkYXRhIGFycmF5IHRoZSBwYXJ0aWNpcGFudHMgdGhhdCB0aGUgdXNlciBoYXMgaGlkZGVuIChyZW1vdmVkX3Rvb2xzKVxuICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgd2hlcmUgdGhlIHRvb2xzIHRoYXQgaGF2ZSBub3QgYmVlbiBoaWRkZW4gd2lsbCBiZSBzdG9yZWRcbiAgbGV0IHRvb2xzX25vdF9oaWRkZW4gPSBbXTtcbiAgZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGxldCBpbmRleCA9ICQuaW5BcnJheShlbGVtZW50LnRvb2xuYW1lLnJlcGxhY2UoL1tcXC4gKCkvX10vZywgXCItXCIpLCByZW1vdmVkX3Rvb2xzKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpe1xuICAgICAgdG9vbHNfbm90X2hpZGRlbi5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRvb2xzX25vdF9oaWRkZW47XG5cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/remove_tools.js\n");

/***/ }),

/***/ "./src/scatter_plot.js":
/*!*****************************!*\
  !*** ./src/scatter_plot.js ***!
  \*****************************/
/*! exports provided: createChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createChart\", function() { return createChart; });\n/* harmony import */ var _chart_coordinates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart_coordinates */ \"./src/chart_coordinates.js\");\n/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend */ \"./src/legend.js\");\n/* harmony import */ var _classification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classification */ \"./src/classification.js\");\n\n;\n\n\n\nfunction createChart (data,divid, classification_type, metric_x, metric_y, metrics_names, better){\n\n  let margin = {top: Math.round($(window).height()* 0.0318), right:  Math.round($(window).width()* 0.0261), bottom: compute_chart_height(data), left:  Math.round($(window).width()* 0.0373)},\n    width = Math.round($(window).width()* 0.6818) - margin.left - margin.right,\n    height = Math.round($(window).height()* 0.7787037) - margin.top - margin.bottom;\n\n  let min_x = d3.min(data, function(d) { return d.x; });\n  let max_x = d3.max(data, function(d) { return d.x; });\n\n  //the x axis domain is calculated based in the difference between the max and min, and the average stderr (BETA)\n  var proportion = get_avg_stderr(data, \"x\")/(max_x-min_x);\n\n  let xScale = d3.scaleLinear()\n    .range([0, width])\n    .domain([min_x - proportion*(max_x-min_x), max_x + proportion*(max_x-min_x)]).nice();\n\n  let min_y = d3.min(data, function(d) { return d.y; });\n  let max_y = d3.max(data, function(d) { return d.y; });\n\n  //the y axis domain is calculated based in the difference between the max and min, and the average stderr (BETA)\n  proportion = get_avg_stderr(data, \"y\")/(max_y-min_y);\n\n  let yScale = d3.scaleLinear()\n    .range([height, 0])\n    .domain([min_y - proportion*(max_y-min_y), max_y + proportion*(max_y-min_y)]).nice();\n\n  let xAxis = d3.axisBottom(xScale).ticks(12),\n      yAxis = d3.axisLeft(yScale).ticks(12 * height / width);\n\n  let line = d3.line()\n    .x(function(d) {\n      return xScale(d.x);\n    })\n    .y(function(d) {\n      return yScale(d.y);\n    });\n\n  // Define the div for the tooltip\n\n  let div = d3.select('body').append(\"div\").attr(\"class\", \"benchmark_tooltip\").style(\"opacity\", 0);\n\n  // append the svg element\n  // d3.select(\"svg\").remove()\n    // console.log(d3.select(\"svg\").remove());\n  let svg = d3.select('#'+divid + \"flex-container\").append(\"svg\")\n    .attr(\"class\", \"benchmarkingSVG\")\n    .attr(\"viewBox\", \"0 0 \" + (width + margin.left + margin.right) + \" \" + (height + margin.top + margin.bottom))\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr('id','svg_'+divid)\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n  \n    var g = svg.append(\"g\");\nvar zoom = d3.zoom().on(\"zoom\", function () { \n        console.log(\"zoom\", d3, d3.event);\n        g.attr(\"transform\", d3.event.transform);\n    });\n\nsvg.call(zoom);\n\nupdateDownloadURL(svg.node(), document.getElementById('download'));\n\n  svg.append(\"g\").append(\"rect\").attr(\"width\", width).attr(\"height\", height).attr(\"class\", \"plot-bg\");\n\n  // Add Axis numbers\n  svg.append(\"g\").attr(\"class\", \"axis axis--x\")\n    .attr(\"transform\", \"translate(\" + 0 + \",\" + height + \")\")\n    .call(xAxis);\n\n  svg.append(\"g\").attr(\"class\", \"axis axis--y\").call(yAxis);\n\n  // add axis labels\n  if (metric_x.startsWith(\"OEBM\") == true){\n    var txt_x = metrics_names[metric_x];\n  } else {\n    var txt_x = metric_x;\n  };\n  if (metric_y.startsWith(\"OEBM\") == true){\n    var txt_y = metrics_names[metric_y];\n  } else {\n    var txt_y = metric_y;\n  };\n  svg.append(\"text\")             \n  .attr(\"transform\",\n        \"translate(\" + (width/2) + \" ,\" + \n                       (height + margin.top + (Math.round($(window).height()* 0.0347))) + \")\")\n  .style(\"text-anchor\", \"middle\")\n  .style(\"font-weight\", \"bold\")\n  .style(\"font-size\", \".95vw\")\n  .text(txt_x);\n\n  svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"y\", 0 - margin.left)\n      .attr(\"x\",0 - (height / 2))\n      .attr(\"dy\", \"1em\")\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-weight\", \"bold\")\n      .style(\"font-size\", \".95vw\")\n      .text(txt_y ); \n  \n  // add pareto legend\n\n  svg.append(\"line\")\n  .attr(\"x1\", 0)\n  .attr(\"y1\", height + margin.top + (Math.round($(window).height()* 0.0347)) )\n  .attr(\"x2\", Math.round($(window).width()* 0.02083))\n  .attr(\"y2\", height + margin.top + (Math.round($(window).height()* 0.0347)) )\n\n  .attr(\"stroke\", \"grey\")\n  .attr(\"stroke-width\",2)\n  .style(\"stroke-dasharray\", (\"15, 5\"))\n  .style(\"opacity\", 0.7)  \n  \n  svg.append(\"text\")             \n  .attr(\"transform\",\n        \"translate(\" + (Math.round($(window).width()* 0.05208)) + \" ,\" + \n                       (height + margin.top + (Math.round($(window).height()* 0.0347)) + 5) + \")\")\n  .style(\"text-anchor\", \"middle\")\n  // .style(\"font-weight\", \"bold\")\n  .style(\"font-size\", \".75vw\")\n  .text(\"Pareto frontier\");\n\n\n  // add X and Y Gridlines\n  var gridlines_x = d3.axisBottom()\n                    .ticks(12)\n                    .tickFormat(\"\")\n                    .tickSize(height)\n                    .scale(xScale);\n\n  var gridlines_y = d3.axisLeft()\n                    .ticks(12 * height / width)\n                    .tickFormat(\"\")\n                    .tickSize(-width)\n                    .scale(yScale);\n\n  svg.append(\"g\")\n     .attr(\"class\", \"bench_grid\")\n     .call(gridlines_x);\n  \n     svg.append(\"g\")\n     .attr(\"class\", \"bench_grid\")\n     .call(gridlines_y);\n  \n     \n  // add OpenEBench Credits\n  svg.append(\"a\")\n  .attr(\"xlink:href\", \"https://openebench.bsc.es\")\n  .attr(\"target\", \"_blank\")\n  .append(\"rect\")  \n  // .attr(\"transform\",\n  //       \"translate(\" + (Math.round($(window).width()* 0.49)) + \" ,\" + \n  //       (height + margin.top + (Math.round($(window).height()* 0.02))) + \")\")\n  .attr(\"transform\",\n        \"translate(\" + (Math.round($(window).width()* 0.49)) + \" ,\" + \n        ( margin.top - (Math.round($(window).height()* 0.057))) + \")\")\n  .attr(\"height\", Math.round($(window).height()* 0.0235))\n  .attr(\"width\", Math.round($(window).width()* 0.145))\n  .style(\"fill\", \"white\")\n  .attr(\"rx\", 10)\n  .attr(\"ry\", 10);\n\n  svg.append(\"text\") \n  .attr(\"class\", \"OEB_text_link\")   \n  .style(\"pointer-events\", \"none\")         \n  // .attr(\"transform\",\n  //       \"translate(\" + (Math.round($(window).width()* 0.55)) + \" ,\" + \n  //       (height + margin.top + (Math.round($(window).height()* 0.0347)) + 5) + \")\")\n  .attr(\"transform\",\n        \"translate(\" + (Math.round($(window).width()* 0.55)) + \" ,\" + \n        ( margin.top - (Math.round($(window).height()* 0.04))) + \")\")\n  .style(\"text-anchor\", \"middle\")\n  .style(\"font-style\", \"italic\")\n  .style(\"font-size\", \".75vw\")\n  .text(\"Powered by OpenEBench\");\n\n  svg.append(\"svg:image\")\n  // .attr(\"transform\",\n  // \"translate(\" + (Math.round($(window).width()* 0.6)) + \" ,\" + \n  // (height + margin.top + (Math.round($(window).height()* 0.015))) + \")\")\n  .attr(\"transform\",\n        \"translate(\" + (Math.round($(window).width()* 0.6)) + \" ,\" + \n        ( margin.top - (Math.round($(window).height()* 0.064))) + \")\")\n.attr('width', Math.round($(window).width()* 0.03))\n.attr('height', Math.round($(window).height()* 0.03))\n.attr(\"xlink:href\", \"images/logo.png\")\n.style(\"pointer-events\", \"none\");\n\nlet removed_tools = []; // this array stores the tools when the user clicks on them\n\n   // setup fill color\n  let cValue_func = function(d) {\n    return d.toolname;\n  },\n  color_func = d3.scaleOrdinal(d3.schemeSet1.concat(d3.schemeSet3).concat(d3.schemeSet2));\n\n    // get object with tools and colors:\n    var legend_color_palette = {};\n    data.forEach(function(element) {\n      legend_color_palette[element.toolname] = color_func(element.toolname);\n    });\n\n\n  Object(_chart_coordinates__WEBPACK_IMPORTED_MODULE_0__[\"append_dots_errobars\"]) (svg, data, xScale, yScale, div, cValue_func, color_func,divid, metric_x, metric_y, metrics_names);\n\n  Object(_legend__WEBPACK_IMPORTED_MODULE_1__[\"draw_legend\"]) (data, svg, xScale, yScale, div, width, height, removed_tools, color_func, color_func.domain(), divid,classification_type, legend_color_palette);\n\n  Object(_classification__WEBPACK_IMPORTED_MODULE_2__[\"compute_classification\"])(data, svg, xScale, yScale, div, width, height, removed_tools,divid, classification_type, legend_color_palette, better[divid]);\n\n  };\n\n  function compute_chart_height(data){\n\n    if (data.length%5 == 0){\n      return (90 + (20 * (Math.trunc(data.length/5))));\n    } else if (data.lenght%5 != 0) {\n      return (90 + (20 * (Math.trunc(data.length/5)+1)));\n    } \n    \n  };\n\n  function get_avg_stderr(data, axis){\n\n    var sum = 0;\n\n    data.forEach(function(element) {\n      if (axis == \"y\"){\n        sum = sum + element.e_y;\n      } else if (axis == \"x\"){\n        sum = sum + element.e_x;\n      }\n    });\n  \n    return sum/data.length\n  \n  }\n\n  function zoomed(svg) {\n    svg.attr(\"transform\", \"translate(\" + d3.event.translate + \")scale(\" + d3.event.scale + \")\");\n  }\n\n  // Download solution\nfunction getDownloadURL(svg, callback) {\n  \n  var canvas;\n  var source = svg.parentNode.innerHTML;\n  var image = d3.select('body').append('img')\n    .style('display', 'none')\n    .attr('width', 960)\n    .attr('height', 500)\n    .node();\n  console.log(image)\n  // image.onerror = function() {\n  //   callback(new Error('An error occurred while attempting to load SVG'));\n  // };\n  image.onload = function() {\n    canvas = d3.select('body').append('canvas')\n      .style('display', 'none')\n      .attr('width', 960)\n      .attr('height', 500)\n      .node();\n\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0);\n    var url = canvas.toDataURL('image/png');\n\n    d3.selectAll([ canvas, image ]).remove();\n\n    callback(null, url);\n  };\n  image.src = 'data:image/svg+xml,' + encodeURIComponent(source);\n  console.log(\"vaa\")\n}\n\nfunction updateDownloadURL(svg, link) {\n  console.log(svg, link)\n  getDownloadURL(svg, function(error, url) {\n    console.log(url)\n    if (error) {\n      console.error(error);\n    } else {\n      link.href = url;\n    }\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NhdHRlcl9wbG90LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjYXR0ZXJfcGxvdC5qcz9mYmM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcGVuZF9kb3RzX2Vycm9iYXJzIH0gZnJvbSAnLi9jaGFydF9jb29yZGluYXRlcydcbmltcG9ydCB7IGRyYXdfbGVnZW5kIH0gZnJvbSBcIi4vbGVnZW5kXCI7O1xuaW1wb3J0IHsgY29tcHV0ZV9jbGFzc2lmaWNhdGlvbiB9IGZyb20gXCIuL2NsYXNzaWZpY2F0aW9uXCI7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNoYXJ0IChkYXRhLGRpdmlkLCBjbGFzc2lmaWNhdGlvbl90eXBlLCBtZXRyaWNfeCwgbWV0cmljX3ksIG1ldHJpY3NfbmFtZXMsIGJldHRlcil7XG5cbiAgbGV0IG1hcmdpbiA9IHt0b3A6IE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjAzMTgpLCByaWdodDogIE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuMDI2MSksIGJvdHRvbTogY29tcHV0ZV9jaGFydF9oZWlnaHQoZGF0YSksIGxlZnQ6ICBNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjAzNzMpfSxcbiAgICB3aWR0aCA9IE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuNjgxOCkgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC43Nzg3MDM3KSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gIGxldCBtaW5feCA9IGQzLm1pbihkYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pO1xuICBsZXQgbWF4X3ggPSBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KTtcblxuICAvL3RoZSB4IGF4aXMgZG9tYWluIGlzIGNhbGN1bGF0ZWQgYmFzZWQgaW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbWF4IGFuZCBtaW4sIGFuZCB0aGUgYXZlcmFnZSBzdGRlcnIgKEJFVEEpXG4gIHZhciBwcm9wb3J0aW9uID0gZ2V0X2F2Z19zdGRlcnIoZGF0YSwgXCJ4XCIpLyhtYXhfeC1taW5feCk7XG5cbiAgbGV0IHhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAuZG9tYWluKFttaW5feCAtIHByb3BvcnRpb24qKG1heF94LW1pbl94KSwgbWF4X3ggKyBwcm9wb3J0aW9uKihtYXhfeC1taW5feCldKS5uaWNlKCk7XG5cbiAgbGV0IG1pbl95ID0gZDMubWluKGRhdGEsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSk7XG4gIGxldCBtYXhfeSA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pO1xuXG4gIC8vdGhlIHkgYXhpcyBkb21haW4gaXMgY2FsY3VsYXRlZCBiYXNlZCBpbiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBtYXggYW5kIG1pbiwgYW5kIHRoZSBhdmVyYWdlIHN0ZGVyciAoQkVUQSlcbiAgcHJvcG9ydGlvbiA9IGdldF9hdmdfc3RkZXJyKGRhdGEsIFwieVwiKS8obWF4X3ktbWluX3kpO1xuXG4gIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgIC5kb21haW4oW21pbl95IC0gcHJvcG9ydGlvbioobWF4X3ktbWluX3kpLCBtYXhfeSArIHByb3BvcnRpb24qKG1heF95LW1pbl95KV0pLm5pY2UoKTtcblxuICBsZXQgeEF4aXMgPSBkMy5heGlzQm90dG9tKHhTY2FsZSkudGlja3MoMTIpLFxuICAgICAgeUF4aXMgPSBkMy5heGlzTGVmdCh5U2NhbGUpLnRpY2tzKDEyICogaGVpZ2h0IC8gd2lkdGgpO1xuXG4gIGxldCBsaW5lID0gZDMubGluZSgpXG4gICAgLngoZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHhTY2FsZShkLngpO1xuICAgIH0pXG4gICAgLnkoZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHlTY2FsZShkLnkpO1xuICAgIH0pO1xuXG4gIC8vIERlZmluZSB0aGUgZGl2IGZvciB0aGUgdG9vbHRpcFxuXG4gIGxldCBkaXYgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsIFwiYmVuY2htYXJrX3Rvb2x0aXBcIikuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuXG4gIC8vIGFwcGVuZCB0aGUgc3ZnIGVsZW1lbnRcbiAgLy8gZDMuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpXG4gICAgLy8gY29uc29sZS5sb2coZDMuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpKTtcbiAgbGV0IHN2ZyA9IGQzLnNlbGVjdCgnIycrZGl2aWQgKyBcImZsZXgtY29udGFpbmVyXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiZW5jaG1hcmtpbmdTVkdcIilcbiAgICAuYXR0cihcInZpZXdCb3hcIiwgXCIwIDAgXCIgKyAod2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgKyBcIiBcIiArIChoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSkpXG4gICAgLmF0dHIoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwieE1pbllNaW4gbWVldFwiKVxuICAgIC5hdHRyKCdpZCcsJ3N2Z18nK2RpdmlkKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gIFxuICAgIHZhciBnID0gc3ZnLmFwcGVuZChcImdcIik7XG52YXIgem9vbSA9IGQzLnpvb20oKS5vbihcInpvb21cIiwgZnVuY3Rpb24gKCkgeyBcbiAgICAgICAgY29uc29sZS5sb2coXCJ6b29tXCIsIGQzLCBkMy5ldmVudCk7XG4gICAgICAgIGcuYXR0cihcInRyYW5zZm9ybVwiLCBkMy5ldmVudC50cmFuc2Zvcm0pO1xuICAgIH0pO1xuXG5zdmcuY2FsbCh6b29tKTtcblxudXBkYXRlRG93bmxvYWRVUkwoc3ZnLm5vZGUoKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkJykpO1xuXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLmFwcGVuZChcInJlY3RcIikuYXR0cihcIndpZHRoXCIsIHdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCkuYXR0cihcImNsYXNzXCIsIFwicGxvdC1iZ1wiKTtcblxuICAvLyBBZGQgQXhpcyBudW1iZXJzXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImF4aXMgYXhpcy0teFwiKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgMCArIFwiLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgLmNhbGwoeEF4aXMpO1xuXG4gIHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImF4aXMgYXhpcy0teVwiKS5jYWxsKHlBeGlzKTtcblxuICAvLyBhZGQgYXhpcyBsYWJlbHNcbiAgaWYgKG1ldHJpY194LnN0YXJ0c1dpdGgoXCJPRUJNXCIpID09IHRydWUpe1xuICAgIHZhciB0eHRfeCA9IG1ldHJpY3NfbmFtZXNbbWV0cmljX3hdO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eHRfeCA9IG1ldHJpY194O1xuICB9O1xuICBpZiAobWV0cmljX3kuc3RhcnRzV2l0aChcIk9FQk1cIikgPT0gdHJ1ZSl7XG4gICAgdmFyIHR4dF95ID0gbWV0cmljc19uYW1lc1ttZXRyaWNfeV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR4dF95ID0gbWV0cmljX3k7XG4gIH07XG4gIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpICAgICAgICAgICAgIFxuICAuYXR0cihcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArICh3aWR0aC8yKSArIFwiICxcIiArIFxuICAgICAgICAgICAgICAgICAgICAgICAoaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMzQ3KSkpICsgXCIpXCIpXG4gIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIuOTV2d1wiKVxuICAudGV4dCh0eHRfeCk7XG5cbiAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgIC5hdHRyKFwieVwiLCAwIC0gbWFyZ2luLmxlZnQpXG4gICAgICAuYXR0cihcInhcIiwwIC0gKGhlaWdodCAvIDIpKVxuICAgICAgLmF0dHIoXCJkeVwiLCBcIjFlbVwiKVxuICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiLjk1dndcIilcbiAgICAgIC50ZXh0KHR4dF95ICk7IFxuICBcbiAgLy8gYWRkIHBhcmV0byBsZWdlbmRcblxuICBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAuYXR0cihcIngxXCIsIDApXG4gIC5hdHRyKFwieTFcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMzQ3KSkgKVxuICAuYXR0cihcIngyXCIsIE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuMDIwODMpKVxuICAuYXR0cihcInkyXCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyAoTWF0aC5yb3VuZCgkKHdpbmRvdykuaGVpZ2h0KCkqIDAuMDM0NykpIClcblxuICAuYXR0cihcInN0cm9rZVwiLCBcImdyZXlcIilcbiAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwyKVxuICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIChcIjE1LCA1XCIpKVxuICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNykgIFxuICBcbiAgc3ZnLmFwcGVuZChcInRleHRcIikgICAgICAgICAgICAgXG4gIC5hdHRyKFwidHJhbnNmb3JtXCIsXG4gICAgICAgIFwidHJhbnNsYXRlKFwiICsgKE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuMDUyMDgpKSArIFwiICxcIiArIFxuICAgICAgICAgICAgICAgICAgICAgICAoaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMzQ3KSkgKyA1KSArIFwiKVwiKVxuICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAvLyAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcbiAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiLjc1dndcIilcbiAgLnRleHQoXCJQYXJldG8gZnJvbnRpZXJcIik7XG5cblxuICAvLyBhZGQgWCBhbmQgWSBHcmlkbGluZXNcbiAgdmFyIGdyaWRsaW5lc194ID0gZDMuYXhpc0JvdHRvbSgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcygxMilcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKGhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHhTY2FsZSk7XG5cbiAgdmFyIGdyaWRsaW5lc195ID0gZDMuYXhpc0xlZnQoKVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoMTIgKiBoZWlnaHQgLyB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHlTY2FsZSk7XG5cbiAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJlbmNoX2dyaWRcIilcbiAgICAgLmNhbGwoZ3JpZGxpbmVzX3gpO1xuICBcbiAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJlbmNoX2dyaWRcIilcbiAgICAgLmNhbGwoZ3JpZGxpbmVzX3kpO1xuICBcbiAgICAgXG4gIC8vIGFkZCBPcGVuRUJlbmNoIENyZWRpdHNcbiAgc3ZnLmFwcGVuZChcImFcIilcbiAgLmF0dHIoXCJ4bGluazpocmVmXCIsIFwiaHR0cHM6Ly9vcGVuZWJlbmNoLmJzYy5lc1wiKVxuICAuYXR0cihcInRhcmdldFwiLCBcIl9ibGFua1wiKVxuICAuYXBwZW5kKFwicmVjdFwiKSAgXG4gIC8vIC5hdHRyKFwidHJhbnNmb3JtXCIsXG4gIC8vICAgICAgIFwidHJhbnNsYXRlKFwiICsgKE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuNDkpKSArIFwiICxcIiArIFxuICAvLyAgICAgICAoaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMikpKSArIFwiKVwiKVxuICAuYXR0cihcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArIChNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjQ5KSkgKyBcIiAsXCIgKyBcbiAgICAgICAgKCBtYXJnaW4udG9wIC0gKE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjA1NykpKSArIFwiKVwiKVxuICAuYXR0cihcImhlaWdodFwiLCBNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMjM1KSlcbiAgLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjE0NSkpXG4gIC5zdHlsZShcImZpbGxcIiwgXCJ3aGl0ZVwiKVxuICAuYXR0cihcInJ4XCIsIDEwKVxuICAuYXR0cihcInJ5XCIsIDEwKTtcblxuICBzdmcuYXBwZW5kKFwidGV4dFwiKSBcbiAgLmF0dHIoXCJjbGFzc1wiLCBcIk9FQl90ZXh0X2xpbmtcIikgICBcbiAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpICAgICAgICAgXG4gIC8vIC5hdHRyKFwidHJhbnNmb3JtXCIsXG4gIC8vICAgICAgIFwidHJhbnNsYXRlKFwiICsgKE1hdGgucm91bmQoJCh3aW5kb3cpLndpZHRoKCkqIDAuNTUpKSArIFwiICxcIiArIFxuICAvLyAgICAgICAoaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMzQ3KSkgKyA1KSArIFwiKVwiKVxuICAuYXR0cihcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArIChNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjU1KSkgKyBcIiAsXCIgKyBcbiAgICAgICAgKCBtYXJnaW4udG9wIC0gKE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjA0KSkpICsgXCIpXCIpXG4gIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiLjc1dndcIilcbiAgLnRleHQoXCJQb3dlcmVkIGJ5IE9wZW5FQmVuY2hcIik7XG5cbiAgc3ZnLmFwcGVuZChcInN2ZzppbWFnZVwiKVxuICAvLyAuYXR0cihcInRyYW5zZm9ybVwiLFxuICAvLyBcInRyYW5zbGF0ZShcIiArIChNYXRoLnJvdW5kKCQod2luZG93KS53aWR0aCgpKiAwLjYpKSArIFwiICxcIiArIFxuICAvLyAoaGVpZ2h0ICsgbWFyZ2luLnRvcCArIChNYXRoLnJvdW5kKCQod2luZG93KS5oZWlnaHQoKSogMC4wMTUpKSkgKyBcIilcIilcbiAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoTWF0aC5yb3VuZCgkKHdpbmRvdykud2lkdGgoKSogMC42KSkgKyBcIiAsXCIgKyBcbiAgICAgICAgKCBtYXJnaW4udG9wIC0gKE1hdGgucm91bmQoJCh3aW5kb3cpLmhlaWdodCgpKiAwLjA2NCkpKSArIFwiKVwiKVxuLmF0dHIoJ3dpZHRoJywgTWF0aC5yb3VuZCgkKHdpbmRvdykud2lkdGgoKSogMC4wMykpXG4uYXR0cignaGVpZ2h0JywgTWF0aC5yb3VuZCgkKHdpbmRvdykuaGVpZ2h0KCkqIDAuMDMpKVxuLmF0dHIoXCJ4bGluazpocmVmXCIsIFwiaW1hZ2VzL2xvZ28ucG5nXCIpXG4uc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cbmxldCByZW1vdmVkX3Rvb2xzID0gW107IC8vIHRoaXMgYXJyYXkgc3RvcmVzIHRoZSB0b29scyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGVtXG5cbiAgIC8vIHNldHVwIGZpbGwgY29sb3JcbiAgbGV0IGNWYWx1ZV9mdW5jID0gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLnRvb2xuYW1lO1xuICB9LFxuICBjb2xvcl9mdW5jID0gZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZVNldDEuY29uY2F0KGQzLnNjaGVtZVNldDMpLmNvbmNhdChkMy5zY2hlbWVTZXQyKSk7XG5cbiAgICAvLyBnZXQgb2JqZWN0IHdpdGggdG9vbHMgYW5kIGNvbG9yczpcbiAgICB2YXIgbGVnZW5kX2NvbG9yX3BhbGV0dGUgPSB7fTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgbGVnZW5kX2NvbG9yX3BhbGV0dGVbZWxlbWVudC50b29sbmFtZV0gPSBjb2xvcl9mdW5jKGVsZW1lbnQudG9vbG5hbWUpO1xuICAgIH0pO1xuXG5cbiAgYXBwZW5kX2RvdHNfZXJyb2JhcnMgKHN2ZywgZGF0YSwgeFNjYWxlLCB5U2NhbGUsIGRpdiwgY1ZhbHVlX2Z1bmMsIGNvbG9yX2Z1bmMsZGl2aWQsIG1ldHJpY194LCBtZXRyaWNfeSwgbWV0cmljc19uYW1lcyk7XG5cbiAgZHJhd19sZWdlbmQgKGRhdGEsIHN2ZywgeFNjYWxlLCB5U2NhbGUsIGRpdiwgd2lkdGgsIGhlaWdodCwgcmVtb3ZlZF90b29scywgY29sb3JfZnVuYywgY29sb3JfZnVuYy5kb21haW4oKSwgZGl2aWQsY2xhc3NpZmljYXRpb25fdHlwZSwgbGVnZW5kX2NvbG9yX3BhbGV0dGUpO1xuXG4gIGNvbXB1dGVfY2xhc3NpZmljYXRpb24oZGF0YSwgc3ZnLCB4U2NhbGUsIHlTY2FsZSwgZGl2LCB3aWR0aCwgaGVpZ2h0LCByZW1vdmVkX3Rvb2xzLGRpdmlkLCBjbGFzc2lmaWNhdGlvbl90eXBlLCBsZWdlbmRfY29sb3JfcGFsZXR0ZSwgYmV0dGVyW2RpdmlkXSk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjb21wdXRlX2NoYXJ0X2hlaWdodChkYXRhKXtcblxuICAgIGlmIChkYXRhLmxlbmd0aCU1ID09IDApe1xuICAgICAgcmV0dXJuICg5MCArICgyMCAqIChNYXRoLnRydW5jKGRhdGEubGVuZ3RoLzUpKSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5naHQlNSAhPSAwKSB7XG4gICAgICByZXR1cm4gKDkwICsgKDIwICogKE1hdGgudHJ1bmMoZGF0YS5sZW5ndGgvNSkrMSkpKTtcbiAgICB9IFxuICAgIFxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldF9hdmdfc3RkZXJyKGRhdGEsIGF4aXMpe1xuXG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGF4aXMgPT0gXCJ5XCIpe1xuICAgICAgICBzdW0gPSBzdW0gKyBlbGVtZW50LmVfeTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInhcIil7XG4gICAgICAgIHN1bSA9IHN1bSArIGVsZW1lbnQuZV94O1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gc3VtL2RhdGEubGVuZ3RoXG4gIFxuICB9XG5cbiAgZnVuY3Rpb24gem9vbWVkKHN2Zykge1xuICAgIHN2Zy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZDMuZXZlbnQudHJhbnNsYXRlICsgXCIpc2NhbGUoXCIgKyBkMy5ldmVudC5zY2FsZSArIFwiKVwiKTtcbiAgfVxuXG4gIC8vIERvd25sb2FkIHNvbHV0aW9uXG5mdW5jdGlvbiBnZXREb3dubG9hZFVSTChzdmcsIGNhbGxiYWNrKSB7XG4gIFxuICB2YXIgY2FudmFzO1xuICB2YXIgc291cmNlID0gc3ZnLnBhcmVudE5vZGUuaW5uZXJIVE1MO1xuICB2YXIgaW1hZ2UgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ2ltZycpXG4gICAgLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKVxuICAgIC5hdHRyKCd3aWR0aCcsIDk2MClcbiAgICAuYXR0cignaGVpZ2h0JywgNTAwKVxuICAgIC5ub2RlKCk7XG4gIGNvbnNvbGUubG9nKGltYWdlKVxuICAvLyBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIC8vICAgY2FsbGJhY2sobmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIGxvYWQgU1ZHJykpO1xuICAvLyB9O1xuICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBjYW52YXMgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ2NhbnZhcycpXG4gICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpXG4gICAgICAuYXR0cignd2lkdGgnLCA5NjApXG4gICAgICAuYXR0cignaGVpZ2h0JywgNTAwKVxuICAgICAgLm5vZGUoKTtcblxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICB2YXIgdXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cbiAgICBkMy5zZWxlY3RBbGwoWyBjYW52YXMsIGltYWdlIF0pLnJlbW92ZSgpO1xuXG4gICAgY2FsbGJhY2sobnVsbCwgdXJsKTtcbiAgfTtcbiAgaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHNvdXJjZSk7XG4gIGNvbnNvbGUubG9nKFwidmFhXCIpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURvd25sb2FkVVJMKHN2ZywgbGluaykge1xuICBjb25zb2xlLmxvZyhzdmcsIGxpbmspXG4gIGdldERvd25sb2FkVVJMKHN2ZywgZnVuY3Rpb24oZXJyb3IsIHVybCkge1xuICAgIGNvbnNvbGUubG9nKHVybClcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgfVxuICB9KTtcbn1cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scatter_plot.js\n");

/***/ }),

/***/ "./src/selection_list.js":
/*!*******************************!*\
  !*** ./src/selection_list.js ***!
  \*******************************/
/*! exports provided: append_classifiers_list */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"append_classifiers_list\", function() { return append_classifiers_list; });\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n\n\n\nfunction append_classifiers_list(divid){\n\n// append buttons\n      let button1_id = divid + \"__none\";\n      let button2_id = divid + \"__squares\";\n      let button3_id = divid + \"__diagonals\";\n      let button4_id = divid + \"__clusters\";\n      \n      // append selection list tooltip container\n      d3.select('#'+divid).append(\"div\")\n        .attr(\"id\", \"tooltip_container\")\n\n        let select_list = d3.select('#'+divid).append(\"form\").append(\"select\")\n        .attr(\"class\",\"classificators_list\")\n        .attr(\"id\",divid + \"_dropdown_list\")\n        .on('change', function(d) {\n          let active_chart = document.getElementById(this.options[this.selectedIndex].id.split(\"__\")[0])\n          let metric_x = active_chart.getAttribute('metric_x');\n          let metric_y = active_chart.getAttribute('metric_y');\n          Object(_app__WEBPACK_IMPORTED_MODULE_0__[\"onQuartileChange\"])(this.options[this.selectedIndex].id, metric_x, metric_y, _app__WEBPACK_IMPORTED_MODULE_0__[\"better\"]);\n        })\n        .append(\"optgroup\")\n        .attr(\"label\",\"Select a classification method:\");\n        \n        d3.select('#'+divid).append(\"div\").attr(\"class\", \"flex-container\").attr(\"id\", divid + \"flex-container\")\n\n        select_list.append(\"option\")\n        .attr(\"class\", \"selection_option\")\n        .attr(\"id\", button1_id)\n        .attr(\"title\", \"Show only raw data\")\n        .attr(\"selected\",\"disabled\")\n        .attr(\"data-toggle\", \"list_tooltip\")\n        .attr(\"data-container\", \"#tooltip_container\") \n        .text(\"NO CLASSIFICATION\")\n        \n        select_list.append(\"option\")\n        .attr(\"class\", \"selection_option\")\n        .attr(\"id\", button2_id)\n        .attr(\"title\", \"Apply square quartiles classification method (based on the 0.5 quartile of the X and Y metrics)\")\n        .attr(\"data-toggle\", \"list_tooltip\")\n        .attr(\"data-container\", \"#tooltip_container\") \n        .text(\"SQUARE QUARTILES\")\n  \n        select_list.append(\"option\")\n        .attr(\"class\", \"selection_option\")\n        .attr(\"id\", button3_id)\n        .attr(\"title\", \"Apply diagonal quartiles classifcation method (based on the assignment of a score to each participant proceeding from its distance to the 'optimal performance' corner)\")\n        .attr(\"data-toggle\", \"list_tooltip\")\n        .attr(\"data-container\", \"#tooltip_container\") \n        .text(\"DIAGONAL QUARTILES\")\n\n        select_list.append(\"option\")\n        .attr(\"class\", \"selection_option\")\n        .attr(\"id\", button4_id)\n        .attr(\"title\", \"Apply K-Means clustering method (group the participants using the K-means clustering algorithm and sort the clusters according to the performance)\")\n        .attr(\"data-toggle\", \"list_tooltip\")\n        .attr(\"data-container\", \"#tooltip_container\") \n        .text(\"K-MEANS CLUSTERING\")\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VsZWN0aW9uX2xpc3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0aW9uX2xpc3QuanM/OGQxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvblF1YXJ0aWxlQ2hhbmdlIH0gZnJvbSBcIi4vYXBwXCJcbmltcG9ydCB7IGJldHRlciB9IGZyb20gXCIuL2FwcFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfY2xhc3NpZmllcnNfbGlzdChkaXZpZCl7XG5cbi8vIGFwcGVuZCBidXR0b25zXG4gICAgICBsZXQgYnV0dG9uMV9pZCA9IGRpdmlkICsgXCJfX25vbmVcIjtcbiAgICAgIGxldCBidXR0b24yX2lkID0gZGl2aWQgKyBcIl9fc3F1YXJlc1wiO1xuICAgICAgbGV0IGJ1dHRvbjNfaWQgPSBkaXZpZCArIFwiX19kaWFnb25hbHNcIjtcbiAgICAgIGxldCBidXR0b240X2lkID0gZGl2aWQgKyBcIl9fY2x1c3RlcnNcIjtcbiAgICAgIFxuICAgICAgLy8gYXBwZW5kIHNlbGVjdGlvbiBsaXN0IHRvb2x0aXAgY29udGFpbmVyXG4gICAgICBkMy5zZWxlY3QoJyMnK2RpdmlkKS5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRvb2x0aXBfY29udGFpbmVyXCIpXG5cbiAgICAgICAgbGV0IHNlbGVjdF9saXN0ID0gZDMuc2VsZWN0KCcjJytkaXZpZCkuYXBwZW5kKFwiZm9ybVwiKS5hcHBlbmQoXCJzZWxlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiY2xhc3NpZmljYXRvcnNfbGlzdFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsZGl2aWQgKyBcIl9kcm9wZG93bl9saXN0XCIpXG4gICAgICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGxldCBhY3RpdmVfY2hhcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS5pZC5zcGxpdChcIl9fXCIpWzBdKVxuICAgICAgICAgIGxldCBtZXRyaWNfeCA9IGFjdGl2ZV9jaGFydC5nZXRBdHRyaWJ1dGUoJ21ldHJpY194Jyk7XG4gICAgICAgICAgbGV0IG1ldHJpY195ID0gYWN0aXZlX2NoYXJ0LmdldEF0dHJpYnV0ZSgnbWV0cmljX3knKTtcbiAgICAgICAgICBvblF1YXJ0aWxlQ2hhbmdlKHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLmlkLCBtZXRyaWNfeCwgbWV0cmljX3ksIGJldHRlcik7XG4gICAgICAgIH0pXG4gICAgICAgIC5hcHBlbmQoXCJvcHRncm91cFwiKVxuICAgICAgICAuYXR0cihcImxhYmVsXCIsXCJTZWxlY3QgYSBjbGFzc2lmaWNhdGlvbiBtZXRob2Q6XCIpO1xuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KCcjJytkaXZpZCkuYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJjbGFzc1wiLCBcImZsZXgtY29udGFpbmVyXCIpLmF0dHIoXCJpZFwiLCBkaXZpZCArIFwiZmxleC1jb250YWluZXJcIilcblxuICAgICAgICBzZWxlY3RfbGlzdC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdGlvbl9vcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBidXR0b24xX2lkKVxuICAgICAgICAuYXR0cihcInRpdGxlXCIsIFwiU2hvdyBvbmx5IHJhdyBkYXRhXCIpXG4gICAgICAgIC5hdHRyKFwic2VsZWN0ZWRcIixcImRpc2FibGVkXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJsaXN0X3Rvb2x0aXBcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcIiN0b29sdGlwX2NvbnRhaW5lclwiKSBcbiAgICAgICAgLnRleHQoXCJOTyBDTEFTU0lGSUNBVElPTlwiKVxuICAgICAgICBcbiAgICAgICAgc2VsZWN0X2xpc3QuYXBwZW5kKFwib3B0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3Rpb25fb3B0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgYnV0dG9uMl9pZClcbiAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCBcIkFwcGx5IHNxdWFyZSBxdWFydGlsZXMgY2xhc3NpZmljYXRpb24gbWV0aG9kIChiYXNlZCBvbiB0aGUgMC41IHF1YXJ0aWxlIG9mIHRoZSBYIGFuZCBZIG1ldHJpY3MpXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJsaXN0X3Rvb2x0aXBcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcIiN0b29sdGlwX2NvbnRhaW5lclwiKSBcbiAgICAgICAgLnRleHQoXCJTUVVBUkUgUVVBUlRJTEVTXCIpXG4gIFxuICAgICAgICBzZWxlY3RfbGlzdC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdGlvbl9vcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBidXR0b24zX2lkKVxuICAgICAgICAuYXR0cihcInRpdGxlXCIsIFwiQXBwbHkgZGlhZ29uYWwgcXVhcnRpbGVzIGNsYXNzaWZjYXRpb24gbWV0aG9kIChiYXNlZCBvbiB0aGUgYXNzaWdubWVudCBvZiBhIHNjb3JlIHRvIGVhY2ggcGFydGljaXBhbnQgcHJvY2VlZGluZyBmcm9tIGl0cyBkaXN0YW5jZSB0byB0aGUgJ29wdGltYWwgcGVyZm9ybWFuY2UnIGNvcm5lcilcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcImxpc3RfdG9vbHRpcFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiI3Rvb2x0aXBfY29udGFpbmVyXCIpIFxuICAgICAgICAudGV4dChcIkRJQUdPTkFMIFFVQVJUSUxFU1wiKVxuXG4gICAgICAgIHNlbGVjdF9saXN0LmFwcGVuZChcIm9wdGlvblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0aW9uX29wdGlvblwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGJ1dHRvbjRfaWQpXG4gICAgICAgIC5hdHRyKFwidGl0bGVcIiwgXCJBcHBseSBLLU1lYW5zIGNsdXN0ZXJpbmcgbWV0aG9kIChncm91cCB0aGUgcGFydGljaXBhbnRzIHVzaW5nIHRoZSBLLW1lYW5zIGNsdXN0ZXJpbmcgYWxnb3JpdGhtIGFuZCBzb3J0IHRoZSBjbHVzdGVycyBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1hbmNlKVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwibGlzdF90b29sdGlwXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCIjdG9vbHRpcF9jb250YWluZXJcIikgXG4gICAgICAgIC50ZXh0KFwiSy1NRUFOUyBDTFVTVEVSSU5HXCIpXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/selection_list.js\n");

/***/ }),

/***/ "./src/squares.js":
/*!************************!*\
  !*** ./src/squares.js ***!
  \************************/
/*! exports provided: get_square_quartiles, append_quartile_numbers_to_plot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_square_quartiles\", function() { return get_square_quartiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"append_quartile_numbers_to_plot\", function() { return append_quartile_numbers_to_plot; });\n/* harmony import */ var _remove_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove_tools */ \"./src/remove_tools.js\");\n/* harmony import */ var _table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table */ \"./src/table.js\");\n\n\n\nfunction get_square_quartiles(data, svg, xScale, yScale, div, removed_tools,better, divid, transform_to_table, legend_color_palette) {\n\n    let tools_not_hidden = Object(_remove_tools__WEBPACK_IMPORTED_MODULE_0__[\"remove_hidden_tools\"])(data, removed_tools);\n  \n    // compute the quartiles over the new seet of data\n    let x_values = tools_not_hidden.map(a => a.x).sort(function(a, b){return a - b});\n    let y_values = tools_not_hidden.map(a => a.y).sort(function(a, b){return a - b});\n  \n    let quantile_x = d3.quantile(x_values, 0.5);\n    let quantile_y = d3.quantile(y_values, 0.5);\n  \n    let x_axis = xScale.domain();\n    let y_axis = yScale.domain();\n  \n    let formatComma = d3.format(\",\");\n  \n    svg.append(\"line\")\n      .attr(\"x1\", xScale(quantile_x))\n      .attr(\"y1\", yScale(y_axis[0]))\n      .attr(\"x2\", xScale(quantile_x))\n      .attr(\"y2\", yScale(y_axis[1]))\n      .attr(\"id\", function (d) { return divid+\"___x_quartile\";})\n      .attr(\"stroke\", \"#0A58A2\")\n      .attr(\"stroke-width\",2)\n      .style(\"stroke-dasharray\", (\"20, 5\"))\n      .style(\"opacity\", 0.4)\n      .on(\"mouseover\", function(d) {\t\n        div.transition()\t\t\n           .duration(100)\t\t\n           .style(\"opacity\", .9);\t\t\n        div.html(\"X quartile = \" + formatComma( quantile_x) )\t\n           .style(\"left\", (d3.event.pageX) + \"px\")\t\t\n           .style(\"top\", (d3.event.pageY) + \"px\");\n      })\t\t\t\t\t\n      .on(\"mouseout\", function(d) {\t\t\n        div.transition()\t\t\n           .duration(1000)\t\t\n           .style(\"opacity\", 0);\t\n      });\n  \n    svg.append(\"line\")\n      .attr(\"x1\", xScale(x_axis[0]))\n      .attr(\"y1\", yScale(quantile_y))\n      .attr(\"x2\", xScale(x_axis[1]))\n      .attr(\"y2\", yScale(quantile_y))\n      .attr(\"id\", function (d) { return divid+\"___y_quartile\";})\n      .attr(\"stroke\", \"#0A58A2\")\n      .attr(\"stroke-width\",2)\n      .style(\"stroke-dasharray\", (\"20, 5\"))\n      .style(\"opacity\", 0.4)\n      .on(\"mouseover\", function(d) {\t\n        div.transition()\t\t\n           .duration(100)\t\t\n           .style(\"opacity\", .9);\t\t\n        div\t.html(\"Y quartile = \" + formatComma(quantile_y) )\t\n            .style(\"left\", (d3.event.pageX) + \"px\")\t\t\n            .style(\"top\", (d3.event.pageY) + \"px\");\n      })\t\t\t\t\t\n      .on(\"mouseout\", function(d) {\t\t\n        div.transition()\t\t\n           .duration(1500)\t\t\n           .style(\"opacity\", 0);\t\n      });\n  \n      //the tranformation to tabular format is done only if there are any table elements in the html file\n      if (transform_to_table == true) {\n        transform_sqr_classif_to_table(better, tools_not_hidden, quantile_x, quantile_y, divid, legend_color_palette, data, removed_tools);\n      };\n      \n  };\n  \n  function transform_sqr_classif_to_table(better, data, quantile_x, quantile_y, divid, legend_color_palette, all_participants, removed_tools){\n    if (better == \"bottom-right\"){\n      data.forEach(function(element) {\n          if (element['x'] >= quantile_x && element['y'] <= quantile_y){\n                element['quartile'] = 1;\n          }else if (element['x'] >= quantile_x && element['y'] > quantile_y){\n                element['quartile'] = 3;\n          }else if (element['x'] < quantile_x && element['y'] > quantile_y){\n                element['quartile'] = 4;\n          }else if (element['x'] < quantile_x && element['y'] <= quantile_y){\n                element['quartile'] = 2;\n          }\n      });\n    } else if (better == \"top-right\"){\n        data.forEach(function(element) {\n          if (element['x'] >= quantile_x && element['y'] < quantile_y){\n                element['quartile'] = 3;\n          }else if (element['x'] >= quantile_x && element['y'] >= quantile_y){\n                element['quartile'] = 1;\n          }else if (element['x'] < quantile_x && element['y'] >= quantile_y){\n                element['quartile'] = 2;\n          }else if (element['x'] < quantile_x && element['y'] < quantile_y){\n                element['quartile'] = 4;\n          }\n        });\n    };\n  \n    Object(_table__WEBPACK_IMPORTED_MODULE_1__[\"fill_in_table\"]) (divid, data, all_participants, removed_tools);\n    Object(_table__WEBPACK_IMPORTED_MODULE_1__[\"set_cell_colors\"])(divid, legend_color_palette, removed_tools);\n  \n  };\n  \n  \n  function append_quartile_numbers_to_plot (svg, xScale, yScale, better,divid){\n  \n    let x_axis = xScale.domain();\n    let y_axis = yScale.domain();\n  \n    let num_bottom_right,num_bottom_left,num_top_right,num_top_left;\n    // append quartile numbers to plot\n    if (better == \"bottom-right\"){\n       num_bottom_right = \"1\";\n       num_bottom_left = \"2\";\n       num_top_right = \"3\";\n       num_top_left = \"4\";\n    } \n    else if (better == \"top-right\"){\n       num_bottom_right = \"3\";\n       num_bottom_left = \"4\";\n       num_top_right = \"1\";\n       num_top_left = \"2\";\n    };\n  \n    \n    svg.append(\"text\")\n    .attr(\"id\", function (d) { return divid+\"___num_bottom_right\";})\n    .attr(\"x\", xScale(x_axis[1]-(0.05*(x_axis[1]-x_axis[0]))))\n    .attr(\"y\", yScale(y_axis[1]-(0.97*(y_axis[1]-y_axis[0]))))\n    .style(\"opacity\", 0.4)\n    .style(\"font-size\", \"2vw\")\n    .style(\"fill\", \"#0A58A2\")\n    .text(num_bottom_right);\n  \n    svg.append(\"text\")\n    .attr(\"id\", function (d) { return divid+\"___num_bottom_left\";})\n    .attr(\"x\", xScale(x_axis[1]-(0.98*(x_axis[1]-x_axis[0]))))\n    .attr(\"y\", yScale(y_axis[1]-(0.97*(y_axis[1]-y_axis[0]))))\n    .style(\"opacity\", 0.4)\n    .style(\"font-size\", \"2vw\")\n    .style(\"fill\", \"#0A58A2\")\n    .text(num_bottom_left);\n  \n    svg.append(\"text\")\n    .attr(\"id\", function (d) { return divid+\"___num_top_right\";})\n    .attr(\"x\", xScale(x_axis[1]-(0.05*(x_axis[1]-x_axis[0]))))\n    .attr(\"y\", yScale(y_axis[1]-(0.1*(y_axis[1]-y_axis[0]))))\n    .style(\"opacity\", 0.4)\n    .style(\"font-size\", \"2vw\")\n    .style(\"fill\", \"#0A58A2\")\n    .text(num_top_right);\n  \n    svg.append(\"text\")\n    .attr(\"id\", function (d) { return divid+\"___num_top_left\";})\n    .attr(\"x\", xScale(x_axis[1]-(0.98*(x_axis[1]-x_axis[0]))))\n    .attr(\"y\", yScale(y_axis[1]-(0.1*(y_axis[1]-y_axis[0]))))\n    .style(\"opacity\", 0.4)\n    .style(\"font-size\", \"2vw\")\n    .style(\"fill\", \"#0A58A2\")\n    .text(num_top_left);\n  \n  }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3F1YXJlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zcXVhcmVzLmpzPzZmYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVtb3ZlX2hpZGRlbl90b29sc30gZnJvbSBcIi4vcmVtb3ZlX3Rvb2xzXCI7XG5pbXBvcnQgeyBmaWxsX2luX3RhYmxlLCBzZXRfY2VsbF9jb2xvcnMgfSBmcm9tIFwiLi90YWJsZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3F1YXJlX3F1YXJ0aWxlcyhkYXRhLCBzdmcsIHhTY2FsZSwgeVNjYWxlLCBkaXYsIHJlbW92ZWRfdG9vbHMsYmV0dGVyLCBkaXZpZCwgdHJhbnNmb3JtX3RvX3RhYmxlLCBsZWdlbmRfY29sb3JfcGFsZXR0ZSkge1xuXG4gICAgbGV0IHRvb2xzX25vdF9oaWRkZW4gPSByZW1vdmVfaGlkZGVuX3Rvb2xzKGRhdGEsIHJlbW92ZWRfdG9vbHMpO1xuICBcbiAgICAvLyBjb21wdXRlIHRoZSBxdWFydGlsZXMgb3ZlciB0aGUgbmV3IHNlZXQgb2YgZGF0YVxuICAgIGxldCB4X3ZhbHVlcyA9IHRvb2xzX25vdF9oaWRkZW4ubWFwKGEgPT4gYS54KS5zb3J0KGZ1bmN0aW9uKGEsIGIpe3JldHVybiBhIC0gYn0pO1xuICAgIGxldCB5X3ZhbHVlcyA9IHRvb2xzX25vdF9oaWRkZW4ubWFwKGEgPT4gYS55KS5zb3J0KGZ1bmN0aW9uKGEsIGIpe3JldHVybiBhIC0gYn0pO1xuICBcbiAgICBsZXQgcXVhbnRpbGVfeCA9IGQzLnF1YW50aWxlKHhfdmFsdWVzLCAwLjUpO1xuICAgIGxldCBxdWFudGlsZV95ID0gZDMucXVhbnRpbGUoeV92YWx1ZXMsIDAuNSk7XG4gIFxuICAgIGxldCB4X2F4aXMgPSB4U2NhbGUuZG9tYWluKCk7XG4gICAgbGV0IHlfYXhpcyA9IHlTY2FsZS5kb21haW4oKTtcbiAgXG4gICAgbGV0IGZvcm1hdENvbW1hID0gZDMuZm9ybWF0KFwiLFwiKTtcbiAgXG4gICAgc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwieDFcIiwgeFNjYWxlKHF1YW50aWxlX3gpKVxuICAgICAgLmF0dHIoXCJ5MVwiLCB5U2NhbGUoeV9heGlzWzBdKSlcbiAgICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKHF1YW50aWxlX3gpKVxuICAgICAgLmF0dHIoXCJ5MlwiLCB5U2NhbGUoeV9heGlzWzFdKSlcbiAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19feF9xdWFydGlsZVwiO30pXG4gICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwQTU4QTJcIilcbiAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMilcbiAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgKFwiMjAsIDVcIikpXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XHRcbiAgICAgICAgZGl2LnRyYW5zaXRpb24oKVx0XHRcbiAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcdFx0XG4gICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1x0XHRcbiAgICAgICAgZGl2Lmh0bWwoXCJYIHF1YXJ0aWxlID0gXCIgKyBmb3JtYXRDb21tYSggcXVhbnRpbGVfeCkgKVx0XG4gICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYKSArIFwicHhcIilcdFx0XG4gICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkpICsgXCJweFwiKTtcbiAgICAgIH0pXHRcdFx0XHRcdFxuICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oZCkge1x0XHRcbiAgICAgICAgZGl2LnRyYW5zaXRpb24oKVx0XHRcbiAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXHRcdFxuICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1x0XG4gICAgICB9KTtcbiAgXG4gICAgc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwieDFcIiwgeFNjYWxlKHhfYXhpc1swXSkpXG4gICAgICAuYXR0cihcInkxXCIsIHlTY2FsZShxdWFudGlsZV95KSlcbiAgICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKHhfYXhpc1sxXSkpXG4gICAgICAuYXR0cihcInkyXCIsIHlTY2FsZShxdWFudGlsZV95KSlcbiAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19feV9xdWFydGlsZVwiO30pXG4gICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwQTU4QTJcIilcbiAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMilcbiAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgKFwiMjAsIDVcIikpXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XHRcbiAgICAgICAgZGl2LnRyYW5zaXRpb24oKVx0XHRcbiAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcdFx0XG4gICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1x0XHRcbiAgICAgICAgZGl2XHQuaHRtbChcIlkgcXVhcnRpbGUgPSBcIiArIGZvcm1hdENvbW1hKHF1YW50aWxlX3kpIClcdFxuICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCAoZDMuZXZlbnQucGFnZVgpICsgXCJweFwiKVx0XHRcbiAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkpICsgXCJweFwiKTtcbiAgICAgIH0pXHRcdFx0XHRcdFxuICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oZCkge1x0XHRcbiAgICAgICAgZGl2LnRyYW5zaXRpb24oKVx0XHRcbiAgICAgICAgICAgLmR1cmF0aW9uKDE1MDApXHRcdFxuICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1x0XG4gICAgICB9KTtcbiAgXG4gICAgICAvL3RoZSB0cmFuZm9ybWF0aW9uIHRvIHRhYnVsYXIgZm9ybWF0IGlzIGRvbmUgb25seSBpZiB0aGVyZSBhcmUgYW55IHRhYmxlIGVsZW1lbnRzIGluIHRoZSBodG1sIGZpbGVcbiAgICAgIGlmICh0cmFuc2Zvcm1fdG9fdGFibGUgPT0gdHJ1ZSkge1xuICAgICAgICB0cmFuc2Zvcm1fc3FyX2NsYXNzaWZfdG9fdGFibGUoYmV0dGVyLCB0b29sc19ub3RfaGlkZGVuLCBxdWFudGlsZV94LCBxdWFudGlsZV95LCBkaXZpZCwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIGRhdGEsIHJlbW92ZWRfdG9vbHMpO1xuICAgICAgfTtcbiAgICAgIFxuICB9O1xuICBcbiAgZnVuY3Rpb24gdHJhbnNmb3JtX3Nxcl9jbGFzc2lmX3RvX3RhYmxlKGJldHRlciwgZGF0YSwgcXVhbnRpbGVfeCwgcXVhbnRpbGVfeSwgZGl2aWQsIGxlZ2VuZF9jb2xvcl9wYWxldHRlLCBhbGxfcGFydGljaXBhbnRzLCByZW1vdmVkX3Rvb2xzKXtcbiAgICBpZiAoYmV0dGVyID09IFwiYm90dG9tLXJpZ2h0XCIpe1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudFsneCddID49IHF1YW50aWxlX3ggJiYgZWxlbWVudFsneSddIDw9IHF1YW50aWxlX3kpe1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSAxO1xuICAgICAgICAgIH1lbHNlIGlmIChlbGVtZW50Wyd4J10gPj0gcXVhbnRpbGVfeCAmJiBlbGVtZW50Wyd5J10gPiBxdWFudGlsZV95KXtcbiAgICAgICAgICAgICAgICBlbGVtZW50WydxdWFydGlsZSddID0gMztcbiAgICAgICAgICB9ZWxzZSBpZiAoZWxlbWVudFsneCddIDwgcXVhbnRpbGVfeCAmJiBlbGVtZW50Wyd5J10gPiBxdWFudGlsZV95KXtcbiAgICAgICAgICAgICAgICBlbGVtZW50WydxdWFydGlsZSddID0gNDtcbiAgICAgICAgICB9ZWxzZSBpZiAoZWxlbWVudFsneCddIDwgcXVhbnRpbGVfeCAmJiBlbGVtZW50Wyd5J10gPD0gcXVhbnRpbGVfeSl7XG4gICAgICAgICAgICAgICAgZWxlbWVudFsncXVhcnRpbGUnXSA9IDI7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChiZXR0ZXIgPT0gXCJ0b3AtcmlnaHRcIil7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRbJ3gnXSA+PSBxdWFudGlsZV94ICYmIGVsZW1lbnRbJ3knXSA8IHF1YW50aWxlX3kpe1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSAzO1xuICAgICAgICAgIH1lbHNlIGlmIChlbGVtZW50Wyd4J10gPj0gcXVhbnRpbGVfeCAmJiBlbGVtZW50Wyd5J10gPj0gcXVhbnRpbGVfeSl7XG4gICAgICAgICAgICAgICAgZWxlbWVudFsncXVhcnRpbGUnXSA9IDE7XG4gICAgICAgICAgfWVsc2UgaWYgKGVsZW1lbnRbJ3gnXSA8IHF1YW50aWxlX3ggJiYgZWxlbWVudFsneSddID49IHF1YW50aWxlX3kpe1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSAyO1xuICAgICAgICAgIH1lbHNlIGlmIChlbGVtZW50Wyd4J10gPCBxdWFudGlsZV94ICYmIGVsZW1lbnRbJ3knXSA8IHF1YW50aWxlX3kpe1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbJ3F1YXJ0aWxlJ10gPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgXG4gICAgZmlsbF9pbl90YWJsZSAoZGl2aWQsIGRhdGEsIGFsbF9wYXJ0aWNpcGFudHMsIHJlbW92ZWRfdG9vbHMpO1xuICAgIHNldF9jZWxsX2NvbG9ycyhkaXZpZCwgbGVnZW5kX2NvbG9yX3BhbGV0dGUsIHJlbW92ZWRfdG9vbHMpO1xuICBcbiAgfTtcbiAgXG4gIFxuICBleHBvcnQgZnVuY3Rpb24gYXBwZW5kX3F1YXJ0aWxlX251bWJlcnNfdG9fcGxvdCAoc3ZnLCB4U2NhbGUsIHlTY2FsZSwgYmV0dGVyLGRpdmlkKXtcbiAgXG4gICAgbGV0IHhfYXhpcyA9IHhTY2FsZS5kb21haW4oKTtcbiAgICBsZXQgeV9heGlzID0geVNjYWxlLmRvbWFpbigpO1xuICBcbiAgICBsZXQgbnVtX2JvdHRvbV9yaWdodCxudW1fYm90dG9tX2xlZnQsbnVtX3RvcF9yaWdodCxudW1fdG9wX2xlZnQ7XG4gICAgLy8gYXBwZW5kIHF1YXJ0aWxlIG51bWJlcnMgdG8gcGxvdFxuICAgIGlmIChiZXR0ZXIgPT0gXCJib3R0b20tcmlnaHRcIil7XG4gICAgICAgbnVtX2JvdHRvbV9yaWdodCA9IFwiMVwiO1xuICAgICAgIG51bV9ib3R0b21fbGVmdCA9IFwiMlwiO1xuICAgICAgIG51bV90b3BfcmlnaHQgPSBcIjNcIjtcbiAgICAgICBudW1fdG9wX2xlZnQgPSBcIjRcIjtcbiAgICB9IFxuICAgIGVsc2UgaWYgKGJldHRlciA9PSBcInRvcC1yaWdodFwiKXtcbiAgICAgICBudW1fYm90dG9tX3JpZ2h0ID0gXCIzXCI7XG4gICAgICAgbnVtX2JvdHRvbV9sZWZ0ID0gXCI0XCI7XG4gICAgICAgbnVtX3RvcF9yaWdodCA9IFwiMVwiO1xuICAgICAgIG51bV90b3BfbGVmdCA9IFwiMlwiO1xuICAgIH07XG4gIFxuICAgIFxuICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19udW1fYm90dG9tX3JpZ2h0XCI7fSlcbiAgICAuYXR0cihcInhcIiwgeFNjYWxlKHhfYXhpc1sxXS0oMC4wNSooeF9heGlzWzFdLXhfYXhpc1swXSkpKSlcbiAgICAuYXR0cihcInlcIiwgeVNjYWxlKHlfYXhpc1sxXS0oMC45NyooeV9heGlzWzFdLXlfYXhpc1swXSkpKSlcbiAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIydndcIilcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzBBNThBMlwiKVxuICAgIC50ZXh0KG51bV9ib3R0b21fcmlnaHQpO1xuICBcbiAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRpdmlkK1wiX19fbnVtX2JvdHRvbV9sZWZ0XCI7fSlcbiAgICAuYXR0cihcInhcIiwgeFNjYWxlKHhfYXhpc1sxXS0oMC45OCooeF9heGlzWzFdLXhfYXhpc1swXSkpKSlcbiAgICAuYXR0cihcInlcIiwgeVNjYWxlKHlfYXhpc1sxXS0oMC45NyooeV9heGlzWzFdLXlfYXhpc1swXSkpKSlcbiAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNClcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIydndcIilcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzBBNThBMlwiKVxuICAgIC50ZXh0KG51bV9ib3R0b21fbGVmdCk7XG4gIFxuICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19udW1fdG9wX3JpZ2h0XCI7fSlcbiAgICAuYXR0cihcInhcIiwgeFNjYWxlKHhfYXhpc1sxXS0oMC4wNSooeF9heGlzWzFdLXhfYXhpc1swXSkpKSlcbiAgICAuYXR0cihcInlcIiwgeVNjYWxlKHlfYXhpc1sxXS0oMC4xKih5X2F4aXNbMV0teV9heGlzWzBdKSkpKVxuICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC40KVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjJ2d1wiKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjMEE1OEEyXCIpXG4gICAgLnRleHQobnVtX3RvcF9yaWdodCk7XG4gIFxuICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGl2aWQrXCJfX19udW1fdG9wX2xlZnRcIjt9KVxuICAgIC5hdHRyKFwieFwiLCB4U2NhbGUoeF9heGlzWzFdLSgwLjk4Kih4X2F4aXNbMV0teF9heGlzWzBdKSkpKVxuICAgIC5hdHRyKFwieVwiLCB5U2NhbGUoeV9heGlzWzFdLSgwLjEqKHlfYXhpc1sxXS15X2F4aXNbMF0pKSkpXG4gICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjQpXG4gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMnZ3XCIpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiMwQTU4QTJcIilcbiAgICAudGV4dChudW1fdG9wX2xlZnQpO1xuICBcbiAgfSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/squares.js\n");

/***/ }),

/***/ "./src/table.js":
/*!**********************!*\
  !*** ./src/table.js ***!
  \**********************/
/*! exports provided: fill_in_table, set_cell_colors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fill_in_table\", function() { return fill_in_table; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set_cell_colors\", function() { return set_cell_colors; });\n\nfunction fill_in_table (divid, data, all_participants, removed_tools){\n\n  //create table dinamically\n  var table = document.getElementById(divid + \"_table\");\n  var row = table.insertRow(-1);\n  row.insertCell(0).innerHTML = \"<b>TOOL</b>\";\n  row.insertCell(1).innerHTML = \"<b>QUARTILE</b>\";\n\n  all_participants.forEach(function(element) {\n    var row = table.insertRow(-1);\n    row.insertCell(0).innerHTML = element.toolname;\n    //if the participant is not hidden the 2nd column is filled with the corresponding quartile\n    // if not it is filled with --\n    if ($.inArray(element.toolname.replace(/[\\. ()/_]/g, \"-\"), removed_tools) == -1) {\n      // var quartile;\n      let obj = data.find(o => o.toolname.replace(/[\\. ()/_]/g, \"-\") === element.toolname.replace(/[\\. ()/_]/g, \"-\"));\n      row.insertCell(1).innerHTML = obj.quartile;\n    } else {\n      row.insertCell(1).innerHTML = \"--\";\n    }\n    \n    // add id\n    var my_cell = row.cells[0];\n    my_cell.id = divid+\"___cell\"+element.toolname.replace(/[\\. ()/-]/g, \"_\");\n\n    my_cell.addEventListener('click', function (d) {\n\n      let ID = this.id;\n      // trigger a click event on the legend rectangle (hide participant)\n      let legend_rect = (divid+\"___leg_rect\"+ ID.split(\"___cell\")[1]);\n      document.getElementById(legend_rect).dispatchEvent(new Event('click'));\n    });\n\n    my_cell.addEventListener('mouseover', function (d) {\n\n      let ID = this.id;\n      d3.select(this).style(\"cursor\", \"pointer\");\n      let legend_rect = (divid+\"___leg_rect\"+ ID.split(\"___cell\")[1]);\n\n      if (d3.select(this).style(\"opacity\") == 1 || d3.select(this).style(\"opacity\") == 0.5){\n        $(this).css('opacity', 0.7);\n        $(this).closest(\"tr\").css('opacity', 0.7);\n      } else {\n        $(this).css('opacity', 1);\n        $(this).closest(\"tr\").css('opacity', 1);\n      };\n\n    });\n\n    my_cell.addEventListener('mouseout', function (d) {\n      \n      let ID = this.id;\n      d3.select(this).style(\"cursor\", \"default\");\n      let legend_rect = (divid+\"___leg_rect\"+ ID.split(\"___cell\")[1]);\n\n      if (d3.select(\"#\" + legend_rect).style(\"opacity\") == 0.2 || d3.select(\"#\" + legend_rect).style(\"opacity\") == 0.5){\n        $(this).css('opacity', 0.5);\n        $(this).closest(\"tr\").css('opacity', 0.5);\n      } else {\n        $(this).css('opacity', 1);\n        $(this).closest(\"tr\").css('opacity', 1);\n      };\n\n    });\n\n  });\n\n};\n\nfunction set_cell_colors(divid, legend_color_palette, removed_tools){\n\n  var tools = Object.keys(legend_color_palette);\n\n  var cell = $(\"#\" + divid + \"_table td\"); \n\n  cell.each(function() { //loop through all td elements ie the cells\n\n    var cell_value = $(this).html(); //get the value\n    if (cell_value == 1) { //if then for if value is 1\n      $(this).css({'background' : '#238b45'});   // changes td to red.\n    } else if (cell_value == 2) {\n      $(this).css({'background' : '#74c476'}); \n    } else if (cell_value == 3) {\n      $(this).css({'background' : '#bae4b3'}); \n    } else if (cell_value == 4) {\n      $(this).css({'background' : '#edf8e9'}); \n    } else if (cell_value == \"--\") {\n      $(this).css({'background' : '#f0f0f5'}); \n    } else if ($.inArray(cell_value, tools) > -1 && $.inArray(cell_value.replace(/[\\. ()/_]/g, \"-\"), removed_tools) == -1) {\n      $(this).css({'background' : 'linear-gradient(to left, white 92%, ' + legend_color_palette[cell_value] + ' 8%)'});\n    } else if ($.inArray(cell_value.replace(/[\\. ()/_]/g, \"-\"), removed_tools) > -1) {\n      $(this).css({ 'background' : 'linear-gradient(to left, white 92%, ' + legend_color_palette[cell_value] + ' 8%)', 'opacity': 0.5});\n      $(this).closest(\"tr\").css('opacity', 0.5);\n    } else {\n      $(this).css({'background' : '#FFFFFF'});\n    };\n\n    // lighten(' + legend_color_palette[cell_value] + ', 50%)\n\n  });\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdGFibGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUuanM/ZWU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBmdW5jdGlvbiBmaWxsX2luX3RhYmxlIChkaXZpZCwgZGF0YSwgYWxsX3BhcnRpY2lwYW50cywgcmVtb3ZlZF90b29scyl7XG5cbiAgLy9jcmVhdGUgdGFibGUgZGluYW1pY2FsbHlcbiAgdmFyIHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQgKyBcIl90YWJsZVwiKTtcbiAgdmFyIHJvdyA9IHRhYmxlLmluc2VydFJvdygtMSk7XG4gIHJvdy5pbnNlcnRDZWxsKDApLmlubmVySFRNTCA9IFwiPGI+VE9PTDwvYj5cIjtcbiAgcm93Lmluc2VydENlbGwoMSkuaW5uZXJIVE1MID0gXCI8Yj5RVUFSVElMRTwvYj5cIjtcblxuICBhbGxfcGFydGljaXBhbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciByb3cgPSB0YWJsZS5pbnNlcnRSb3coLTEpO1xuICAgIHJvdy5pbnNlcnRDZWxsKDApLmlubmVySFRNTCA9IGVsZW1lbnQudG9vbG5hbWU7XG4gICAgLy9pZiB0aGUgcGFydGljaXBhbnQgaXMgbm90IGhpZGRlbiB0aGUgMm5kIGNvbHVtbiBpcyBmaWxsZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBxdWFydGlsZVxuICAgIC8vIGlmIG5vdCBpdCBpcyBmaWxsZWQgd2l0aCAtLVxuICAgIGlmICgkLmluQXJyYXkoZWxlbWVudC50b29sbmFtZS5yZXBsYWNlKC9bXFwuICgpL19dL2csIFwiLVwiKSwgcmVtb3ZlZF90b29scykgPT0gLTEpIHtcbiAgICAgIC8vIHZhciBxdWFydGlsZTtcbiAgICAgIGxldCBvYmogPSBkYXRhLmZpbmQobyA9PiBvLnRvb2xuYW1lLnJlcGxhY2UoL1tcXC4gKCkvX10vZywgXCItXCIpID09PSBlbGVtZW50LnRvb2xuYW1lLnJlcGxhY2UoL1tcXC4gKCkvX10vZywgXCItXCIpKTtcbiAgICAgIHJvdy5pbnNlcnRDZWxsKDEpLmlubmVySFRNTCA9IG9iai5xdWFydGlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm93Lmluc2VydENlbGwoMSkuaW5uZXJIVE1MID0gXCItLVwiO1xuICAgIH1cbiAgICBcbiAgICAvLyBhZGQgaWRcbiAgICB2YXIgbXlfY2VsbCA9IHJvdy5jZWxsc1swXTtcbiAgICBteV9jZWxsLmlkID0gZGl2aWQrXCJfX19jZWxsXCIrZWxlbWVudC50b29sbmFtZS5yZXBsYWNlKC9bXFwuICgpLy1dL2csIFwiX1wiKTtcblxuICAgIG15X2NlbGwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xuXG4gICAgICBsZXQgSUQgPSB0aGlzLmlkO1xuICAgICAgLy8gdHJpZ2dlciBhIGNsaWNrIGV2ZW50IG9uIHRoZSBsZWdlbmQgcmVjdGFuZ2xlIChoaWRlIHBhcnRpY2lwYW50KVxuICAgICAgbGV0IGxlZ2VuZF9yZWN0ID0gKGRpdmlkK1wiX19fbGVnX3JlY3RcIisgSUQuc3BsaXQoXCJfX19jZWxsXCIpWzFdKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxlZ2VuZF9yZWN0KS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2xpY2snKSk7XG4gICAgfSk7XG5cbiAgICBteV9jZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XG5cbiAgICAgIGxldCBJRCA9IHRoaXMuaWQ7XG4gICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xuICAgICAgbGV0IGxlZ2VuZF9yZWN0ID0gKGRpdmlkK1wiX19fbGVnX3JlY3RcIisgSUQuc3BsaXQoXCJfX19jZWxsXCIpWzFdKTtcblxuICAgICAgaWYgKGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIikgPT0gMSB8fCBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpID09IDAuNSl7XG4gICAgICAgICQodGhpcykuY3NzKCdvcGFjaXR5JywgMC43KTtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KFwidHJcIikuY3NzKCdvcGFjaXR5JywgMC43KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQodGhpcykuY3NzKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICQodGhpcykuY2xvc2VzdChcInRyXCIpLmNzcygnb3BhY2l0eScsIDEpO1xuICAgICAgfTtcblxuICAgIH0pO1xuXG4gICAgbXlfY2VsbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBcbiAgICAgIGxldCBJRCA9IHRoaXMuaWQ7XG4gICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpO1xuICAgICAgbGV0IGxlZ2VuZF9yZWN0ID0gKGRpdmlkK1wiX19fbGVnX3JlY3RcIisgSUQuc3BsaXQoXCJfX19jZWxsXCIpWzFdKTtcblxuICAgICAgaWYgKGQzLnNlbGVjdChcIiNcIiArIGxlZ2VuZF9yZWN0KS5zdHlsZShcIm9wYWNpdHlcIikgPT0gMC4yIHx8IGQzLnNlbGVjdChcIiNcIiArIGxlZ2VuZF9yZWN0KS5zdHlsZShcIm9wYWNpdHlcIikgPT0gMC41KXtcbiAgICAgICAgJCh0aGlzKS5jc3MoJ29wYWNpdHknLCAwLjUpO1xuICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoXCJ0clwiKS5jc3MoJ29wYWNpdHknLCAwLjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzKS5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KFwidHJcIikuY3NzKCdvcGFjaXR5JywgMSk7XG4gICAgICB9O1xuXG4gICAgfSk7XG5cbiAgfSk7XG5cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2VsbF9jb2xvcnMoZGl2aWQsIGxlZ2VuZF9jb2xvcl9wYWxldHRlLCByZW1vdmVkX3Rvb2xzKXtcblxuICB2YXIgdG9vbHMgPSBPYmplY3Qua2V5cyhsZWdlbmRfY29sb3JfcGFsZXR0ZSk7XG5cbiAgdmFyIGNlbGwgPSAkKFwiI1wiICsgZGl2aWQgKyBcIl90YWJsZSB0ZFwiKTsgXG5cbiAgY2VsbC5lYWNoKGZ1bmN0aW9uKCkgeyAvL2xvb3AgdGhyb3VnaCBhbGwgdGQgZWxlbWVudHMgaWUgdGhlIGNlbGxzXG5cbiAgICB2YXIgY2VsbF92YWx1ZSA9ICQodGhpcykuaHRtbCgpOyAvL2dldCB0aGUgdmFsdWVcbiAgICBpZiAoY2VsbF92YWx1ZSA9PSAxKSB7IC8vaWYgdGhlbiBmb3IgaWYgdmFsdWUgaXMgMVxuICAgICAgJCh0aGlzKS5jc3MoeydiYWNrZ3JvdW5kJyA6ICcjMjM4YjQ1J30pOyAgIC8vIGNoYW5nZXMgdGQgdG8gcmVkLlxuICAgIH0gZWxzZSBpZiAoY2VsbF92YWx1ZSA9PSAyKSB7XG4gICAgICAkKHRoaXMpLmNzcyh7J2JhY2tncm91bmQnIDogJyM3NGM0NzYnfSk7IFxuICAgIH0gZWxzZSBpZiAoY2VsbF92YWx1ZSA9PSAzKSB7XG4gICAgICAkKHRoaXMpLmNzcyh7J2JhY2tncm91bmQnIDogJyNiYWU0YjMnfSk7IFxuICAgIH0gZWxzZSBpZiAoY2VsbF92YWx1ZSA9PSA0KSB7XG4gICAgICAkKHRoaXMpLmNzcyh7J2JhY2tncm91bmQnIDogJyNlZGY4ZTknfSk7IFxuICAgIH0gZWxzZSBpZiAoY2VsbF92YWx1ZSA9PSBcIi0tXCIpIHtcbiAgICAgICQodGhpcykuY3NzKHsnYmFja2dyb3VuZCcgOiAnI2YwZjBmNSd9KTsgXG4gICAgfSBlbHNlIGlmICgkLmluQXJyYXkoY2VsbF92YWx1ZSwgdG9vbHMpID4gLTEgJiYgJC5pbkFycmF5KGNlbGxfdmFsdWUucmVwbGFjZSgvW1xcLiAoKS9fXS9nLCBcIi1cIiksIHJlbW92ZWRfdG9vbHMpID09IC0xKSB7XG4gICAgICAkKHRoaXMpLmNzcyh7J2JhY2tncm91bmQnIDogJ2xpbmVhci1ncmFkaWVudCh0byBsZWZ0LCB3aGl0ZSA5MiUsICcgKyBsZWdlbmRfY29sb3JfcGFsZXR0ZVtjZWxsX3ZhbHVlXSArICcgOCUpJ30pO1xuICAgIH0gZWxzZSBpZiAoJC5pbkFycmF5KGNlbGxfdmFsdWUucmVwbGFjZSgvW1xcLiAoKS9fXS9nLCBcIi1cIiksIHJlbW92ZWRfdG9vbHMpID4gLTEpIHtcbiAgICAgICQodGhpcykuY3NzKHsgJ2JhY2tncm91bmQnIDogJ2xpbmVhci1ncmFkaWVudCh0byBsZWZ0LCB3aGl0ZSA5MiUsICcgKyBsZWdlbmRfY29sb3JfcGFsZXR0ZVtjZWxsX3ZhbHVlXSArICcgOCUpJywgJ29wYWNpdHknOiAwLjV9KTtcbiAgICAgICQodGhpcykuY2xvc2VzdChcInRyXCIpLmNzcygnb3BhY2l0eScsIDAuNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcykuY3NzKHsnYmFja2dyb3VuZCcgOiAnI0ZGRkZGRid9KTtcbiAgICB9O1xuXG4gICAgLy8gbGlnaHRlbignICsgbGVnZW5kX2NvbG9yX3BhbGV0dGVbY2VsbF92YWx1ZV0gKyAnLCA1MCUpXG5cbiAgfSk7XG5cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/table.js\n");

/***/ })

/******/ })));